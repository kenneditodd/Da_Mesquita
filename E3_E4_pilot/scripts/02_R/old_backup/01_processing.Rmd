---
title: "Mouse scRNAseq Processing"
author: "Kennedi Todd"
date: "06/13/2022"
output:
  html_document:
    theme: cerulean
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: inline
---

# Setup
## Set working directory
```{r working_directory}
knitr::opts_knit$set(root.dir = ".")
```

## Load libraries
```{r libraries, message=FALSE, warnings=FALSE}
# load libraries
library(cowplot)  # plot_grid()
library(dplyr)  # left_join()
library(ggplot2)  # ggplot()
library(gridExtra)  # grid.arrange()
library(harmony) # RunHarmony()
library(parallel) # detectCores()
library(Seurat)  # Read10X_h5()
library(stringr) # str_match()
```

## Set variables and thresholds
```{r set_variables_and_thresholds}
# variables
sample_order <- c("E3.2M.M","E3.2M.F","E4.2M.M","E4.2M.F",
                  "E3.14M.M","E3.14M.F","E4.14M.M","E4.14M.F")
age_order <- c("2 months","14 months")
sex_order <- c("Male","Female")
isoform_order <- c("E3","E4")
sample_colors <- c("gray","red","orange","yellow","green","blue","purple","pink")
age_colors <- c("darkgray","chartreuse3")
sex_colors <- c("darkgray","purple")
isoform_colors <- c("darkgray","cornflowerblue")

# thresholds
nCount.min <- 400
nCount.max <- 25000
nFeature.min <- 250
complexity.cutoff <- 0.8
mt.cutoff <- 20
ribo.cutoff <- 20
hb.cutoff <- 3

# set seed
set.seed(8)

# work in parallel
options(mc.cores = detectCores() - 1)
```

## Save functions
These functions with help simultaneously save plots as a png and pdf.
```{r save_functions}
saveToPDF <- function(...) {
    d = dev.copy(pdf,...)
    dev.off(d)
}
saveToPNG <- function(...) {
    d = dev.copy(png,...)
    dev.off(d)
}
```

# Load data
## Merge h5
- We are using CellBender filtered output with false positive rate of 0.05. \
- Two of the files say 'pass2' because the CellBender -total-droplets-included argument was
adjusted. \
```{r read_h5, warning=FALSE}
prefix <- "../../cellbender/"
suffix <- "_fpr_0.05_filtered.h5"

if (file.exists("../../rObjects/mouse_cellbender_merged_h5.rds")) {
  mouse <- readRDS("../../rObjects/mouse_cellbender_merged_h5.rds")
} else {
  # individual sample objects
  E3.2M.F <- CreateSeuratObject(Read10X_h5(paste0(prefix,"pass2_","E3_2M_F",suffix)))
  E3.2M.M <- CreateSeuratObject(Read10X_h5(paste0(prefix,"E3_2M_M",suffix)))
  E3.14M.F <- CreateSeuratObject(Read10X_h5(paste0(prefix,"E3_14M_F",suffix)))
  E3.14M.M <- CreateSeuratObject(Read10X_h5(paste0(prefix,"E3_14M_M",suffix)))
  E4.2M.F <- CreateSeuratObject(Read10X_h5(paste0(prefix,"E4_2M_F",suffix)))
  E4.2M.M <- CreateSeuratObject(Read10X_h5(paste0(prefix,"E4_2M_M",suffix)))
  E4.14M.F <- CreateSeuratObject(Read10X_h5(paste0(prefix,"pass2_","E4_14M_F",suffix)))
  E4.14M.M <- CreateSeuratObject(Read10X_h5(paste0(prefix,"E4_14M_M",suffix)))

  # merge objects
  mouse <- merge(x = E3.2M.F, 
                y = c(E3.2M.M, E3.14M.F, E3.14M.M,
                      E4.2M.F, E4.2M.M, E4.14M.F, E4.14M.M), 
                add.cell.ids = c("E3.2M.F","E3.2M.M","E3.14M.F","E3.14M.M",
                                 "E4.2M.F","E4.2M.M","E4.14M.F","E4.14M.M"), 
                project = "Mouse scRNAseq")
  
  # cleanup and save
  remove(E3.2M.F, E3.2M.M, E3.14M.F, E3.14M.M, E4.2M.F, E4.2M.M, E4.14M.F, E4.14M.M)
  saveRDS(mouse, "../../rObjects/mouse_cellbender_merged_h5.rds")
}

# preview
mouse
```

## Annotation
- Gm* genes are originally annotated by MGI and the *Rik genes are annotated by RIKEN
```{r read_annotation}
# read in annotation file, GENCODE GRCm38 version M23 (Ensembl 98)
if (file.exists("../../rObjects/annotation.rds")) {
  genes <- readRDS("../../rObjects/annotation.rds")
} else {
  gtf.file <- "../../refs/mouse_genes.gtf"
  genes <- rtracklayer::import(gtf.file)
  genes <- as.data.frame(genes)
  genes <- genes[genes$type == "gene",]
  saveRDS(genes, "../../rObjects/annotation.rds")
}
```

## Metadata columns
nCount_RNA = total number of transcripts (UMIs) in a single cell 
nFeature_RNA = number of unique transcripts (features)
```{r add_metadata_columns}
# create sample column
barcodes <- colnames(mouse)
pattern <- "(.+)_[ACGT]+-(\\d+)"
sample <- str_match(barcodes, pattern)[,2]
table(sample)
mouse$sample <- factor(sample, levels = sample_order)
table(mouse$sample)  # check
Idents(mouse) <- mouse$sample

# age column
age <- str_match(mouse$sample, "E\\d.(\\d+)M.[FM]")[,2]
age <- gsub(2,"2 months",age)
age <- gsub(14,"14 months",age)
mouse$age <- factor(age, levels = age_order)

# sex column
sex <- str_match(mouse$sample, "E\\d.\\d+M.([FM])")[,2]
sex <- gsub("F","Female",sex)
sex <- gsub("M","Male",sex)
mouse$sex <- factor(sex, levels = sex_order)

# Apoe isoform column
isoform <- str_match(mouse$sample, "(E\\d).\\d+M.[FM]")[,2]
mouse$isoform <- factor(isoform, levels = isoform_order)

# cell.complexity
mouse$cell.complexity <- log10(mouse$nFeature_RNA) / log10(mouse$nCount_RNA)

# percent.mt
mt.genes <- genes[genes$seqnames == "chrM",13]
mouse$percent.mt <- PercentageFeatureSet(mouse, features = mt.genes)
mt.genes

# percent.ribo
# ribosomal proteins begin with 'Rps' or 'Rpl' in this annotation file
# mitochondrial ribosomes start with 'Mrps' or 'Mrpl'
gene.names <- genes$gene_name
ribo <- gene.names[grep("^Rp[sl]", gene.names)]
mt.ribo <- gene.names[grep("^Mrp[sl]", gene.names)]
ribo.combined <- c(mt.ribo,ribo)
mouse$percent.ribo.protein <- PercentageFeatureSet(mouse, features = ribo.combined)
ribo.combined

# percent.hb
# percent.hb - hemoglobin proteins begin with 'Hbb' or 'Hba' for mouse
hb.genes <- gene.names[grep("^Hb[ba]-", gene.names)]
mouse$percent.hb <- PercentageFeatureSet(mouse, features = hb.genes)
hb.genes
```

# Pre-filtering QC
## Number of cells
```{r prefiltering_cells_per_sample}
# Visualize the number of cell counts per sample
data <- as.data.frame(table(mouse$sample))
colnames(data) <- c("sample","frequency")

ncells1 <- ggplot(data, aes(x = sample, y = frequency, fill = sample)) + 
  geom_col() +
  theme_classic() +
  geom_text(aes(label = frequency), 
            position=position_dodge(width=0.9), 
            vjust=-0.25) +
  scale_fill_manual(values = sample_colors) + 
  scale_y_continuous(breaks = seq(0,12000, by = 3000), limits = c(0,12000)) +
  ggtitle("Raw: cells per sample") +
  theme(legend.position =  "none") + 
  theme(axis.text.x = element_text(angle = 45, hjust=1))
ncells1
```

## Density plots
```{r prefiltering_density, warning=FALSE}
# Visualize nCount_RNA
den1 <- ggplot(mouse@meta.data,
       aes(color = sample,
           x = nCount_RNA,
           fill = sample)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  scale_x_log10() +
  scale_color_manual(values = sample_colors) +
  scale_fill_manual(values = sample_colors) +
  xlab("nCount_RNA") +
  ylab("Density") +
  theme(legend.position =  "none") +
  geom_vline(xintercept = nCount.min) +
  geom_vline(xintercept = nCount.max) +
  theme(legend.key.size = unit(0.25, 'cm'), legend.title = element_text(size=9))

# Visualize nFeature_RNA
den2 <- ggplot(mouse@meta.data,
       aes(color = sample,
           x = nFeature_RNA,
           fill = sample)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  scale_x_log10() +
  scale_color_manual(values = sample_colors) +
  theme(legend.position =  "none") +
  scale_fill_manual(values = sample_colors) +
  xlab("nFeature_RNA") +
  ylab("Density") +
  geom_vline(xintercept = nFeature.min) +
  theme(legend.key.size = unit(0.25, 'cm'), legend.title = element_text(size=9))

# Visualize cell complexity
# Quality cells are usually above 0.85
den3 <- ggplot(mouse@meta.data,
       aes(color = sample,
           x = cell.complexity,
           fill = sample)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  scale_color_manual(values = sample_colors) +
  theme(legend.position =  "none") +
  scale_fill_manual(values = sample_colors) +
  xlab("Cell Complexity (log10(nFeature/nCount))") +
  ylab("Density") +
  geom_vline(xintercept = complexity.cutoff) +
  theme(legend.key.size = unit(0.25, 'cm'), legend.title = element_text(size=9))

# Visualize percent.mt
den4 <- ggplot(mouse@meta.data,
       aes(color = sample,
           x = percent.mt,
           fill = sample)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  scale_x_continuous(n.breaks = 4) +
  geom_vline(xintercept = mt.cutoff) +
  scale_color_manual(values = sample_colors) +
  theme(legend.position =  "none") +
  scale_fill_manual(values = sample_colors) +
  xlab("% Mitochondrial Genes") +
  ylab("Density") +
  theme(legend.key.size = unit(0.25, 'cm'), legend.title = element_text(size=9))

# Visualize percent.ribo.protein
den5 <- ggplot(mouse@meta.data,
       aes(color = sample,
           x = percent.ribo.protein,
           fill = sample)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  scale_x_log10() +
  geom_vline(xintercept = ribo.cutoff) +
  scale_color_manual(values = sample_colors) +
  theme(legend.position =  "none") +
  scale_fill_manual(values = sample_colors) +
  xlab("% Ribosomal Protein Genes") +
  ylab("Density") +
  theme(legend.key.size = unit(0.25, 'cm'), legend.title = element_text(size=9))

# Visualize percent.hb
den6 <- ggplot(mouse@meta.data,
       aes(color = sample,
           x = percent.hb,
           fill = sample)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  scale_x_log10() +
  geom_vline(xintercept = hb.cutoff) +
  scale_color_manual(values = sample_colors) +
  theme(legend.position =  "none") +
  scale_fill_manual(values = sample_colors) +
  xlab("% Hemoglobin Genes") +
  ylab("Density") +
  theme(legend.key.size = unit(0.25, 'cm'), legend.title = element_text(size=9))

# Arrange graphs in grid
plots <- list(den1,den2,den3,den4,den5,den6)
layout <- rbind(c(1,4),c(2,5),c(3,6))
grid <- grid.arrange(grobs = plots, layout_matrix = layout)
```

```{r,echo=FALSE,eval=FALSE}
# save
grid <- grid.arrange(grobs = plots, layout_matrix = layout)
path <- paste0("../../results/density/density_curves_raw")
saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
dev.off()

# cleanup
remove(den1,den2,den3,den4,den5,den6,layout,grid,plots)
```

## Violin plots
```{r prefiltering_violins, warning=FALSE}
# nFeature, nCount, and cell.complexity violins
v1 <- VlnPlot(mouse,
              features = c("nFeature_RNA", "nCount_RNA","cell.complexity"),
              ncol = 3,
              group.by = 'sample',
              cols = sample_colors,
              pt.size = 0)
v1

#  percent violins
v2 <- VlnPlot(mouse,
              features = c("percent.mt","percent.ribo.protein","percent.hb"),
              ncol = 3,
              group.by = 'sample',
              cols = sample_colors,
              pt.size = 0)
v2
```

```{r, echo=FALSE, eval=FALSE}
# save v1
v1
path <- paste0("../../results/violins/violins_nFeature_nCount_complexity_raw")
saveToPDF(paste0(path, ".pdf"), width = 8, height = 4)
dev.off()

# save v2
v2
path <- paste0("../../results/violins/violins_percent_raw")
saveToPDF(paste0(path, ".pdf"), width = 8, height = 4)
dev.off()

# cleanup
remove(v1,v2)
```

## Scatter plots
```{r prefiltering_scatter1, warning=FALSE}
s1 <- ggplot(
  mouse@meta.data,
  aes(x = nCount_RNA, y = nFeature_RNA, color = percent.mt)) + 
  geom_point() + 
  geom_smooth(method = "lm") +
	scale_x_log10() +   	
  scale_y_log10() + 
  theme_classic() +
  geom_vline(xintercept = nCount.min) + 
  geom_hline(yintercept = nFeature.min) + 
  facet_wrap(~sample) +
  scale_colour_gradient(low = "gray90", high = "black", limits =c(0,100))
s1
```

```{r, echo=FALSE, eval=FALSE, warning=FALSE, message=FALSE}
# save
s1
path <- paste0("../../results/scatter/scatter_nFeature_vs_nCount_raw")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# cleanup
remove(s1)
```

```{r prefiltering_scatter2, warning=FALSE}
s2 <- FeatureScatter(mouse,
                     feature1 = "nCount_RNA",
                     feature2 = "percent.mt",
                     group.by = 'sample',
                     cols = sample_colors,
                     shuffle = TRUE)
s2
```

```{r,echo=FALSE,eval=FALSE,warning=FALSE,message=FALSE}
# save
s2
path <- paste0("../../results/scatter/scatter_percentMT_vs_nCount_raw")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# cleanup
remove(s2)
```

# Filtering
## Cell-level filtering
We will filter based on 7 conditions: \
- nCount.min = 400 \
- nCount.max = 25000 \
- nFeature.min = 250 \
- complexity.cutoff = 0.8 \
- mt.cutoff = 20 \
- ribo.cutoff = 20 \
- hb.cutoff = 3 \
```{r cell_filtering}
# filter
mouse.filtered <- subset(mouse,
                        subset = (nCount_RNA > nCount.min) &
                          (nCount_RNA < nCount.max) &
                          (nFeature_RNA > nFeature.min) &
                          (cell.complexity > complexity.cutoff) &
                          (percent.mt < mt.cutoff) &
                          (percent.ribo.protein < ribo.cutoff) &
                          (percent.hb < hb.cutoff))

# print cells removed
print(paste0(dim(mouse)[2] - dim(mouse.filtered)[2]," cells removed"))
```

## Gene-level filtering
Remove lowly expressed genes.  We will keep genes that have at least 1 count in
10 cells.
```{r gene_filtering, warning=FALSE, message=FALSE}
# filter genes
counts <- GetAssayData(object = mouse.filtered, slot = "counts")
nonzero <- counts > 0  # produces logical
keep <- Matrix::rowSums(nonzero) >= 10  # sum the true/false
counts.filtered <- counts[keep,]  # keep certain genes

# overwrite mouse.filtered
mouse.filtered <- CreateSeuratObject(counts.filtered, 
                                    meta.data = mouse.filtered@meta.data)

# print features removed
print(paste0(dim(counts)[1] - dim(counts.filtered)[1], " features removed"))
```

Multiple passes were made to assess whether mitochondrial, ribosomal, and immunoglobulin genes should be removed. Ultimately, removal of these genes enhanced clustering.
```{r}
# remove mt.genes
counts <- GetAssayData(object = mouse.filtered, slot = "counts")
keep <- !rownames(counts) %in% mt.genes # false when mt.gene
counts.filtered <- counts[keep,]

# remove ribo.genes
keep <- !rownames(counts.filtered) %in% ribo.combined
counts.filtered <- counts.filtered[keep,]

# remove Ig genes + Jchain but keep Igha + Ighd to enahnce clustering
gene.types <- c("IG_C_gene","IG_C_pseudogene","IG_D","IG_J_gene","IG_LV_gene",
                "IG_V_gene","IG_V_pseudogene")
keep <- (genes$gene_type) %in% gene.types
ig.genes <- genes[keep,]
ig.genes <- c(ig.genes$gene_name, "Jchain")
ig.genes <- ig.genes[-c(185,192)] # keep Igha and Ighd
ig.genes
keep <- !rownames(counts.filtered) %in% ig.genes
counts.filtered <- counts.filtered[keep,]

# overwrite mouse.filtered
mouse.filtered <- CreateSeuratObject(counts.filtered, 
                                    meta.data = mouse.filtered@meta.data)

# print features removed
print(paste0(dim(counts)[1] - dim(counts.filtered)[1], " features removed"))

# cleanup data
remove(mouse,counts,counts.filtered,nonzero,data)
```

```{r save_before_doublet_finder, echo=FALSE, eval=TRUE}
saveRDS(mouse.filtered, "../../rObjects/mouse_cellbender_filtered.rds")
#mouse.filtered <- readRDS("../../rObjects/mouse_cellbender_filtered.rds")
```

# Post-filtering QC
## Number of cells
```{r number_cells2}
# Visualize the number of cell counts per sample
data <- as.data.frame(table(mouse.filtered$sample))
colnames(data) <- c("sample","frequency")

ncells2 <- ggplot(data, aes(x = sample, y = frequency, fill = sample)) + 
  geom_col() +
  theme_classic() +
  geom_text(aes(label = frequency), 
            position=position_dodge(width=0.9), 
            vjust=-0.25) +
  scale_fill_manual(values = sample_colors) + 
  scale_y_continuous(breaks = seq(0,12000, by = 3000), limits = c(0,12000)) +
  ggtitle("Filtered: cells per sample") +
  theme(legend.position =  "none") + 
  theme(axis.text.x = element_text(angle = 45, hjust=1))

# Arrange graphs in grid
plots <- list(ncells1,ncells2)
layout <- cbind(c(1),c(2))
grid <- grid.arrange(grobs = plots, layout_matrix = layout)
```

```{r,echo=FALSE,eval=FALSE}
# save
grid <- grid.arrange(grobs = plots, layout_matrix = layout)
path <- "../../results/ncells/cells_per_sample"
saveToPDF(paste0(path, ".pdf"), width = 8, height = 4)
dev.off()

# cleanup
remove(ncells1,ncells2,plots,layout,grid,data)
```

## Density plots
```{r postfiltering_density, warning=FALSE}
# Visualize nCount_RNA
den1 <- ggplot(mouse.filtered@meta.data,
       aes(color = sample,
           x = nCount_RNA,
           fill = sample)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  scale_x_log10() +
  scale_color_manual(values = sample_colors) +
  scale_fill_manual(values = sample_colors) +
  xlab("nCount_RNA") +
  ylab("Density") +
  theme(legend.position =  "none") +
  geom_vline(xintercept = nCount.min) +
  geom_vline(xintercept = nCount.max) +
  theme(legend.key.size = unit(0.25, 'cm'), legend.title = element_text(size=9))

# Visualize nFeature_RNA
den2 <- ggplot(mouse.filtered@meta.data,
       aes(color = sample,
           x = nFeature_RNA,
           fill = sample)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  scale_x_log10() +
  scale_color_manual(values = sample_colors) +
  theme(legend.position =  "none") +
  scale_fill_manual(values = sample_colors) +
  xlab("nFeature_RNA") +
  ylab("Density") +
  geom_vline(xintercept = nFeature.min) +
  theme(legend.key.size = unit(0.25, 'cm'), legend.title = element_text(size=9))

# Visualize cell complexity
# Quality cells are usually above 0.85
den3 <- ggplot(mouse.filtered@meta.data,
       aes(color = sample,
           x = cell.complexity,
           fill = sample)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  scale_color_manual(values = sample_colors) +
  theme(legend.position =  "none") +
  scale_fill_manual(values = sample_colors) +
  xlab("Cell Complexity (log10(nFeature/nCount))") +
  ylab("Density") +
  geom_vline(xintercept = complexity.cutoff) +
  theme(legend.key.size = unit(0.25, 'cm'), legend.title = element_text(size=9))

# Visualize percent.mt
den4 <- ggplot(mouse.filtered@meta.data,
       aes(color = sample,
           x = percent.mt,
           fill = sample)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  scale_x_continuous(n.breaks = 4) +
  geom_vline(xintercept = mt.cutoff) +
  scale_color_manual(values = sample_colors) +
  theme(legend.position =  "none") +
  scale_fill_manual(values = sample_colors) +
  xlab("% Mitochondrial Genes") +
  ylab("Density") +
  theme(legend.key.size = unit(0.25, 'cm'), legend.title = element_text(size=9))

# Visualize percent.ribo.protein
den5 <- ggplot(mouse.filtered@meta.data,
       aes(color = sample,
           x = percent.ribo.protein,
           fill = sample)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  scale_x_log10() +
  geom_vline(xintercept = ribo.cutoff) +
  scale_color_manual(values = sample_colors) +
  theme(legend.position =  "none") +
  scale_fill_manual(values = sample_colors) +
  xlab("% Ribosomal Protein Genes") +
  ylab("Density") +
  theme(legend.key.size = unit(0.25, 'cm'), legend.title = element_text(size=9))

# Visualize percent.hb
den6 <- ggplot(mouse.filtered@meta.data,
       aes(color = sample,
           x = percent.hb,
           fill = sample)) +
  geom_density(alpha = 0.2) +
  theme_classic() +
  scale_x_log10() +
  geom_vline(xintercept = hb.cutoff) +
  scale_color_manual(values = sample_colors) +
  theme(legend.position =  "none") +
  scale_fill_manual(values = sample_colors) +
  xlab("% Hemoglobin Genes") +
  ylab("Density") +
  theme(legend.key.size = unit(0.25, 'cm'), legend.title = element_text(size=9))

# Arrange graphs in grid
plots <- list(den1,den2,den3,den4,den5,den6)
layout <- rbind(c(1,4),c(2,5),c(3,6))
grid <- grid.arrange(grobs = plots, layout_matrix = layout)
```

```{r, echo=FALSE, eval=FALSE, warning=FALSE}
# save
grid <- grid.arrange(grobs = plots, layout_matrix = layout)
path <- "../../results/density/density_curves_filtered"
saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
dev.off()

# cleanup
remove(den1,den2,den3,den4,den5,den6,plots,layout,grid)
```

## Violin plots
```{r postfiltering_violins}
# nFeature, nCount, and cell.complexity violins
v3 <- VlnPlot(mouse.filtered,
              features = c("nFeature_RNA", "nCount_RNA","cell.complexity"),
              ncol = 3,
              group.by = 'sample',
              cols = sample_colors,
              pt.size = 0)
v3

#  percent violins
v4 <- VlnPlot(mouse.filtered,
              features = c("percent.mt","percent.ribo.protein","percent.hb"),
              ncol = 3,
              group.by = 'sample',
              cols = sample_colors,
              pt.size = 0)
v4
```

```{r, echo=FALSE, eval=FALSE}
# save
v3
path <- paste0("../../results/violins/violins_nFeature_nCount_complexity_filtered")
saveToPDF(paste0(path, ".pdf"), width = 8, height = 4)
dev.off()

# save
v4
path <- paste0("../../results/violins/violins_percent_filtered")
saveToPDF(paste0(path, ".pdf"), width = 8, height = 4)
dev.off()

# cleanup
remove(v3,v4)
```

## Scatter plots
```{r postfiltering_scatter1}
s3 <- ggplot(
  mouse.filtered@meta.data,
  aes(x = nCount_RNA, y = nFeature_RNA, color = percent.mt)) + 
  geom_point() + 
  geom_smooth(method = "lm") +
	scale_x_log10() +   	
  scale_y_log10() + 
  theme_classic() +
  geom_vline(xintercept = nCount.min) + 
  geom_hline(yintercept = nFeature.min) + 
  facet_wrap(~sample) +
  scale_colour_gradient(low = "gray90", high = "black", limits =c(0,100))
s3
```

```{r,echo=FALSE,eval=FALSE}
# save
s3
path <- paste0("../../results/scatter/scatter_nFeature_vs_nCount_filtered")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# cleanup
remove(s3)
```

```{r postfiltering_scatter2}
s4 <- FeatureScatter(mouse.filtered,
                     feature1 = "nCount_RNA",
                     feature2 = "percent.mt",
                     group.by = 'sample',
                     cols = sample_colors,
                     shuffle = TRUE)
s4
```

```{r,echo=FALSE,eval=FALSE}
# save
s4
path <- "../../results/scatter/scatter_nCount_vs_percentMT_filtered"
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# cleanup
remove(s4)
```

## Box plot
```{r boxplot}
# Visualize the distribution of genes detected per cell via boxplot
b1 <- ggplot(mouse.filtered@meta.data,
       aes(x = sample, 
           y = log10(nFeature_RNA), 
           fill=sample)) + 
  geom_boxplot() + 
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust = 0.5, face="bold")) +
  ggtitle("Unique Genes / Cell / Sample") +
  scale_color_manual(values = sample_colors) +
  scale_fill_manual(values = sample_colors) +
  xlab("Sample")
b1
```

```{r,echo=FALSE,eval=FALSE}
# save
b1
path <- "../../results/boxplot/boxplot_nFeature_per_sample"
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# cleanup
remove(b1)
```

## Top transcripts
- Gm42418: Rn18s-rs5
```{r top_transcripts}
df <- data.frame(row.names = rownames(mouse.filtered))
df$rsum <- rowSums(x = mouse.filtered, slot = "counts")
df$gene_name <- rownames(df)
df <- df[order(df$rsum, decreasing = TRUE),]
head(df, 30)
```

```{r,echo=FALSE,eval=FALSE}
write.table(df, 
            "../../results/tables/top_transcripts.tsv",
            quote = FALSE,
            row.names = FALSE)
```

# Cell cycle
## Score
- [cell cycle scoring guide](https://hbctraining.github.io/scRNA-seq_online/lessons/cell_cycle_scoring.html) \
- The most common biological data correction is to remove the effects of the cell 
cycle on the transcriptome. 
- Raw counts are not comparable between cells. Each cell has a different nCount_RNA. The log normalization, ((nCount_RNA / nFeature_RNA) * log1p, is taken in order to explore variation. \

```{r log_normalize}
# log normalization
mouse.phase <- NormalizeData(mouse.filtered)
```

- Each cell is given score based on expression of G1, G2/M, and S phase markers. \
- G1: ~10 hrs, S:  ~5-6 hrs, G2: ~3-4 hrs, M: ~2 hrs
- G1 (10 hrs) > G2/M (5-6 hrs) = S (5-6 hrs)
- If the score is negative for both S.Score and G2M.Score the phase is G1. Otherwise, the the greatest positive value between S.Score and G2M.Score determines the phase.

```{r score_cell_cycle}
# load mouse cell cycle markers
phase.markers <- read.delim("../../refs/mouse_cell_cycle.txt")
colnames(phase.markers)[2] <- "gene_id"
phase.markers <- left_join(phase.markers, genes[,c(10,13)], by = "gene_id")
g2m <- phase.markers[phase.markers$phase == "G2/M", 4]
g2m
s <- phase.markers[phase.markers$phase == "S", 4]
s

# write table
write.table(phase.markers, 
            "../../results/cellcycle/mouse_cell_cycle_phase_markers.tsv",
            quote = FALSE, sep = "\t", row.names = FALSE)

# score cells
mouse.phase <- CellCycleScoring(mouse.phase,
                                g2m.features = g2m,
                                s.features = s,
                                set.ident = TRUE)
```

## Top variable genes
Find the top variable genes before performing PCA. The data is scaled since
highly expressed genes usually are the most variable. This will make the mean 
expression zero and the variance of each gene across cells is one.
```{r cell_cycle_top_variable_genes}
# Identify the most variable genes
mouse.phase <- FindVariableFeatures(mouse.phase, verbose = FALSE)

# Preview top 40
head(VariableFeatures(mouse.phase), 40)

# Scale the counts
mouse.phase <- ScaleData(mouse.phase)
```

## PCA
If the PCA plots for each phase do not look similar you may want to regress out 
variation due to cell cycle phase. Otherwise, nothing needs to be done.
```{r cell_cycle_pca}
# Run PCA
mouse.phase.pca <- RunPCA(mouse.phase, nfeatures.print = 10)

# Plot
pca1 <- DimPlot(mouse.phase.pca,
               reduction = "pca",
               group.by = "Phase",
               split.by = "Phase")
pca1

pca2 <- DimPlot(mouse.phase.pca,
               reduction = "pca",
               group.by = "Phase",
               shuffle = TRUE)
pca2

# cleanup
remove(mouse.filtered)
```

```{r,echo=FALSE,eval=FALSE,message=FALSE,warning=FALSE}
# save
pca1
path <- paste0("../../results/cellcycle/mouse_cell_cycle_phase_PCA")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# cleanup
remove(pca1,pca2,df,phase.markers)
```

## Bar graph
```{r cell_cycle_bar_graph}
cellCycleBarPlot <- 
  as_tibble(mouse.phase.pca[[]]) %>%
  ggplot(aes(Phase, fill = Phase)) + geom_bar()
cellCycleBarPlot
```

```{r,echo=FALSE,eval=FALSE}
# save
cellCycleBarPlot
path <- paste0("../../results/cellcycle/mouse_cell_cycle_phase_ncells")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# cleanup
remove(cellCycleBarPlot)
```

## Percent cells per phase
```{r percent_cells_per_cluster_phase}
percent.phase <- mouse.phase.pca@meta.data %>%
  group_by(sample, Phase) %>%
  dplyr::count() %>%
  group_by(sample) %>%
  dplyr::mutate(percent = 100*n/sum(n)) %>%
  ungroup() %>%
  ggplot(aes(x = sample, y = percent, fill = Phase)) +
  geom_col() +
  ggtitle("Percentage of phase per sample")
percent.phase
```

```{r,echo=FALSE,eval=FALSE}
# save
percent.phase
path <- "../../results/cellcycle/mouse_cell_cycle_phase_per_sample"
saveToPDF(paste0(path, ".pdf"), width = 8, height = 6)
dev.off()

# cleanup
remove(percent.phase)
```

# Mitochondrial fraction
## PCA
[Evaluating effects of mitochondrial expression](https://hbctraining.github.io/scRNA-seq_online/lessons/06_SC_SCT_normalization.html)
```{r mito_pca}
# Check quartile values and store
summary(mouse.phase.pca$percent.mt)
first <- as.numeric(summary(mouse.phase.pca$percent.mt)[2])
mean <- as.numeric(summary(mouse.phase.pca$percent.mt)[4])
third <- as.numeric(summary(mouse.phase.pca$percent.mt)[5])

# Turn percent.mt into factor based on quartile value
mouse.phase.pca@meta.data$mito.factor <- cut(mouse.phase.pca@meta.data$percent.mt, 
                   breaks=c(-Inf, first, mean, third, Inf), 
                   labels=c("Low","Medium","Medium high", "High"))
mouse.phase[["mito.factor"]] <- mouse.phase.pca$mito.factor

# Plot
pca1 <- DimPlot(mouse.phase.pca,
               reduction = "pca",
               group.by = "mito.factor",
               split.by = "mito.factor")
pca1

pca2 <- DimPlot(mouse.phase.pca,
               reduction = "pca",
               group.by = "mito.factor",
               shuffle = TRUE)
pca2
```

```{r,eval=FALSE,echo=FALSE}
# save
pca1
path <- paste0("../../results/mitochondria/mouse_mitochondria_quartile_PCA")
saveToPDF(paste0(path, ".pdf"), width = 8, height = 6)
dev.off()

# cleanup
remove(pca1,pca2)
```

## Percent cells per quartile
```{r mito_percent_cells}
percent <- mouse.phase.pca@meta.data %>%
  group_by(sample, mito.factor) %>%
  dplyr::count() %>%
  group_by(sample) %>%
  dplyr::mutate(percent = 100*n/sum(n)) %>%
  ungroup() %>%
  ggplot(aes(x = sample, y = percent, fill = mito.factor)) +
  geom_col() +
  ggtitle("Mitochondrial fraction per sample")
percent
```

```{r,echo=FALSE,eval=FALSE}
# save
percent
path <- "../../results/mitochondria/mouse_mitochondria_percent_per_sample"
saveToPDF(paste0(path, ".pdf"), width = 8, height = 6)
dev.off()

# cleanup
remove(percent)
```

# SCTransform
- Now, we can use the SCTransform method as a more accurate method of normalizing, 
estimating the variance of the raw filtered data, and identifying the most 
variable genes. Variation in sequencing depth (total nCount_RNA per cell) is 
normalized using a regularized negative binomial model. \

- Sctransform automatically accounts for cellular sequencing depth by regressing 
out sequencing depth (nUMIs). However, if there are other sources of 
uninteresting variation identified in the data during the exploration steps we 
can also include these. We observed little to no effect due to cell cycle phase or
percent.mito and so we chose not to regress this out of our data. \

- Since we have 8 samples in our dataset we want to keep them as separate objects 
and transform them as that is what is required for integration. \

```{r split_object2}
# split
mouse.split <- SplitObject(mouse.phase, split.by = "sample")
mouse.split

# cleanup
remove(mouse.phase.pca, mouse.phase)
```

- We will use a ‘for loop’ to run the SCTransform() on each sample, and 
regress out mitochondrial expression by specifying in the vars.to.regress 
argument of the SCTransform() function. \

- Before we run this for loop, we know that the output can generate large R 
objects/variables in terms of memory. If we have a large dataset, then we might 
need to adjust the limit for allowable object sizes within R (Default is 500 * 
1024 ^ 2 = 500 Mb). \
```{r sct, message=FALSE, warning=FALSE}
options(future.globals.maxSize = 4000 * 1024^5)

for (i in 1:length(mouse.split)) {
  print(paste0("Sample ", i))
  mouse.split[[i]] <- SCTransform(mouse.split[[i]], verbose = FALSE)
}

mouse.split
```

- NOTE: By default, after normalizing, adjusting the variance, and regressing out 
uninteresting sources of variation, SCTransform will rank the genes by residual 
variance and output the 3000 most variant genes. If the dataset has larger cell 
numbers, then it may be beneficial to adjust this parameter higher using the 
variable.features.n argument. Additionally the last line of output specifies “Set default assay to SCT”.
- It is suggested to not regress out batch, and instead use a data integration method: [github link](https://github.com/satijalab/seurat/issues/3270) \

# Integration
## Run harmony
- Condition-specific clustering of cells indicates that we need to integrate 
the cells across conditions to ensure that cells of the same cell type cluster 
together. \

- To integrate, use the shared highly variable genes from each condition 
identified using SCTransform. Then, integrate conditions to overlay cells that 
are similar or have a “common set of biological features” between groups. \

- Now, using our SCTransform object as input, let’s perform the integration across 
conditions. \

- First, we need to specify that we want to use all of the 3000 most variable 
genes identified by SCTransform for the integration. By default, this function 
selects the top 2000 genes. \

```{r run_harmony, warning=FALSE, message=FALSE}
# Choose the features to use when integrating multiple datasets 
# will use nfeatures as 3000 as defined by running SCTransform above
var.features <- SelectIntegrationFeatures(object.list = mouse.split, 
                                          nfeatures = 3000)

# merge the mouse
mouse.sct.merged <- merge(x = mouse.split[[1]],
                         y = c(mouse.split[[2]], mouse.split[[3]], mouse.split[[4]]))

# define the variable features 
VariableFeatures(mouse.sct.merged) <- var.features

# run PCA on the merged object
mouse.sct.merged <- RunPCA(object = mouse.sct.merged, assay = "SCT")

# harmony dimensional reduction
mouse.integrated <- RunHarmony(object = mouse.sct.merged, 
                              group.by.vars = "sample", 
                              assay.use = "SCT",
                              reduction = "pca", 
                              plot_convergence = TRUE)

# save and cleanup
saveRDS(mouse.integrated, "../../rObjects/mouse_integrated.rds")
remove(mouse.split, var.features, mouse.sct.merged)
```

```{r,echo=FALSE,eval=FALSE}
mouse.integrated <- readRDS("../../rObjects/mouse_integrated.rds")
```

## Check output
```{r check_harmony}
# Reset idents and levels
DefaultAssay(mouse.integrated) <- "SCT"
Idents(mouse.integrated) <- "sample"
mouse.integrated$sample <- factor(mouse.integrated$sample, 
                                  levels = sample_order)
mouse.integrated$age <- factor(mouse.integrated$age, 
                               levels = age_order)
mouse.integrated$sex <- factor(mouse.integrated$sex, 
                               levels = sex_order)
mouse.integrated$isoform <- factor(mouse.integrated$isoform,
                                   levels = isoform_order)


# check PCA
p1 <- DimPlot(object = mouse.integrated, 
              reduction = "harmony",
              group.by = "sample",
              cols = sample_colors,
              shuffle = TRUE) + NoLegend()
p1

p2 <- VlnPlot(object = mouse.integrated, 
              features = "harmony_1", 
              group.by = "sample", 
              pt.size = 0, 
              cols = sample_colors) + NoLegend()
p2
```

## Top variable features
Top 20 variable features
```{r variable_genes}
top20 <- mouse.integrated@assays$SCT@var.features[1:20]
top20
```

## PCA plot
After integration, to visualize the integrated data we can use dimensionality 
reduction techniques, such as PCA and Uniform Manifold Approximation and 
Projection (UMAP). While PCA will determine all PCs, we can only plot two at a 
time. In contrast, UMAP will take the information from any number of top PCs to 
arrange the cells in this multidimensional space. It will take those distances 
in multidimensional space, and try to plot them in two dimensions. In this way, 
the distances between cells represent similarity in expression.

To generate these visualizations with the harmony output, use reduction = "harmony"

```{r plot_harmony}
# Plot PCA
pca1 <- DimPlot(mouse.integrated,
        reduction = "harmony",
        split.by = "sample",
        group.by = "sample",
        cols = sample_colors)
pca1

pca2 <- DimPlot(mouse.integrated,
        reduction = "harmony",
        split.by = "isoform",
        group.by = "isoform",
        cols = isoform_colors)
pca2

pca3 <- DimPlot(mouse.integrated,
        reduction = "harmony",
        split.by = "age",
        group.by = "age",
        cols = age_colors)
pca3

pca4 <- DimPlot(mouse.integrated,
        reduction = "harmony",
        split.by = "sex",
        group.by = "sex",
        cols = sex_colors)
pca4
```

```{r,echo=FALSE,eval=FALSE,message=FALSE,warning=FALSE}
# save pca1
pca1
path <- paste0("../../results/PCA/sample_PCA")
saveToPDF(paste0(path, ".pdf"), width = 10, height = 6)
dev.off()

# save pca2
path <- paste0("../../results/PCA/isoform_PCA")
pca2
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# save pca3
path <- paste0("../../results/PCA/age_PCA")
pca3
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# save pca4
path <- paste0("../../results/PCA/sex_PCA")
pca4
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# cleanup
remove(pca1,pca2,pca3,pca4)
```

# Find significant PCs

To overcome the extensive technical noise in the expression of any single gene 
for scRNA-seq data, Seurat assigns cells to clusters based on their PCA scores 
derived from the expression of the integrated most variable genes, with each PC 
essentially representing a “metagene” that combines information across a 
correlated gene set. Determining how many PCs to include in the clustering step 
is therefore important to ensure that we are capturing the majority of the 
variation, or cell types, present in our dataset.

```{r view_PCs}
# Printing out the most variable genes driving PCs
print(x = mouse.integrated[["pca"]], 
      dims = 1:10,
      nfeatures = 10)
```

Quantitative approach to an elbow plot \
- The point where the principal components only contribute 5% of standard 
  deviation and the principal components cumulatively contribute 90% of the 
  standard deviation. \
- The point where the percent change in variation between the consecutive PCs is 
  less than 0.1%. \

First metric
```{r metric1}
# Determine percent of variation associated with each PC
stdv <- mouse.integrated[["pca"]]@stdev
sum.stdv <- sum(mouse.integrated[["pca"]]@stdev)
percent.stdv <- (stdv / sum.stdv) * 100

# Calculate cumulative percents for each PC
cumulative <- cumsum(percent.stdv)

# Determine which PC exhibits cumulative percent greater than 90% and
# and % variation associated with the PC as less than 5
co1 <- which(cumulative > 90 & percent.stdv < 5)[1]
co1
```

Second metric
```{r metric2}
# Determine the difference between variation of PC and subsequent PC
co2 <- sort(which(
  (percent.stdv[1:length(percent.stdv) - 1] - 
     percent.stdv[2:length(percent.stdv)]) > 0.1), 
  decreasing = T)[1] + 1

# last point where change of % of variation is more than 0.1%.
co2
```

Choose the minimum of these two metrics as the PCs covering 
the majority of the variation in the data.
```{r minimum_PCs}
# Minimum of the two calculation
min.pc <- min(co1, co2)
min.pc
```

## Elbow plot
Use min.pc we just calculated to generate the clusters. We can plot the elbow 
plot again and overlay the information determined using our metrics:
```{r quantitative_elbow}
# Create a dataframe with values
plot_df <- data.frame(pct = percent.stdv, 
           cumu = cumulative, 
           rank = 1:length(percent.stdv))

# Elbow plot to visualize 
  ggplot(plot_df, aes(cumulative, percent.stdv, label = rank, color = rank > min.pc)) + 
  geom_text() + 
  geom_vline(xintercept = 90, color = "grey") + 
  geom_hline(yintercept = min(percent.stdv[percent.stdv > 5]), color = "grey") +
  theme_bw()
```

# Clustering
## Run UMAP
```{r run_UMAP, message=FALSE, warning=FALSE}
# Run UMAP
mouse.integrated <- RunUMAP(mouse.integrated,
                           dims = 1:min.pc,
                           reduction = "harmony",
                           n.components = 3) # set to 3 to use with VR

# plot UMAP
DimPlot(mouse.integrated,
        shuffle = TRUE)
```

## Find clusters

Seurat uses a graph-based clustering approach, which embeds cells in a graph 
structure, using a K-nearest neighbor (KNN) graph (by default), with edges drawn 
between cells with similar gene expression patterns. Then, it attempts to 
partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’ 
[Seurat - Guided Clustering Tutorial]. \

We will use the FindClusters() function to perform the graph-based clustering. 
The resolution is an important argument that sets the “granularity” of the 
downstream clustering and will need to be optimized for every individual experiment. 
For datasets of 3,000 - 5,000 cells, the resolution set between 0.4-1.4 generally 
yields good clustering. Increased resolution values lead to a greater number of 
clusters, which is often required for larger datasets. \

The FindClusters() function allows us to enter a series of resolutions and will 
calculate the “granularity” of the clustering. This is very helpful for testing 
which resolution works for moving forward without having to run the function for 
each resolution. \

```{r find_neighbors, message=FALSE, warning=FALSE}
# Determine the K-nearest neighbor graph
mouse.unannotated <- FindNeighbors(object = mouse.integrated,
                                   assay = "SCT", # set as default after SCTransform
                                   reduction = "harmony",
                                   dims = 1:min.pc)

# Determine the clusters for various resolutions
mouse.unannotated <- FindClusters(object = mouse.unannotated,
                                  algorithm = 1, # 1 = Louvain
                                  resolution = seq(0.1,0.8,by=0.1))
mouse.unannotated$seurat_clusters <- mouse.unannotated$SCT_snn_res.0.5
```

```{r save_final_object,echo=FALSE,eval=TRUE}
# Save integrated seurat object
saveRDS(mouse.unannotated, paste0("../../rObjects/mouse_cellbender_unannotated.rds"))
```

## Explore resolutions
```{r explore_resolutions}
# 0.1
DimPlot(mouse.unannotated,
        group.by = "SCT_snn_res.0.1",
        label = TRUE)

# 0.2
DimPlot(mouse.unannotated,
        group.by = "SCT_snn_res.0.2",
        label = TRUE)

# 0.3
DimPlot(mouse.unannotated,
        group.by = "SCT_snn_res.0.3",
        label = TRUE)

# 0.4
DimPlot(mouse.unannotated,
        group.by = "SCT_snn_res.0.4",
        label = TRUE)

# 0.5
DimPlot(mouse.unannotated,
        group.by = "SCT_snn_res.0.5",
        label = TRUE)
```

# Clustering QC
## Treatment, sample, phase
```{r UMAP_treatment}
# clusters
Idents(mouse.unannotated) <- "SCT_snn_res.0.5"
u1 <- DimPlot(mouse.unannotated,
              label = FALSE,
              split.by = "sample",
              #cols = colors,
              ncol = 2)
u1

# isoform
u2 <- DimPlot(mouse.unannotated,
              label = FALSE, 
              split.by = "isoform",
              group.by = "isoform",
              cols = isoform_colors)
u2

# age
u3 <- DimPlot(mouse.unannotated,
              label = FALSE, 
              split.by = "age",
              group.by = "age",
              cols = age_colors)
u3

# sex
u4 <- DimPlot(mouse.unannotated,
              label = FALSE, 
              split.by = "sex",
              group.by = "sex",
              cols = sex_colors)
u4

# phase
u5 <- DimPlot(mouse.unannotated,
              label = FALSE, 
              split.by = "Phase",
              group.by = "Phase")
u5

# mito.factor
u6 <- DimPlot(mouse.unannotated,
              label = FALSE, 
              split.by = "mito.factor",
              group.by = "mito.factor",
              ncol = 2)
u6
```

```{r,echo=FALSE,eval=FALSE,message=FALSE,warning=FALSE}
# save
path <- "../../results/UMAP/UMAP_unannotated_sample"
u1
saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
dev.off()

path <- "../../results/UMAP/UMAP_unannotated_isoform"
u2
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
dev.off()

path <- "../../results/UMAP/UMAP_unannotated_age"
u3
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
dev.off()

path <- "../../results/UMAP/UMAP_unannotated_sex"
u4
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
dev.off()

path <- "../../results/UMAP/UMAP_unannotated_phase"
u5
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
dev.off()

path <- "../../results/UMAP/UMAP_unannotated_mito_factor"
u6
saveToPDF(paste0(path, ".pdf"), width = 8, height = 6)
dev.off()


remove(u1,u2,u3,u4,u5,u6)
```

## Revisit QC metrics
```{r UMAP_QC, warning=FALSE, message=FALSE}
# nCount
f1 <- FeaturePlot(mouse.unannotated, 
                  features = "nCount_RNA",
                  pt.size = 0.4, 
                  order = TRUE) + 
  scale_colour_gradientn(colours = c("blue","lightblue","yellow","orange","red"))
f1

# nFeature
f2 <- FeaturePlot(mouse.unannotated, 
                  features = "nFeature_RNA",
                  pt.size = 0.4, 
                  order = TRUE) + 
  scale_colour_gradientn(colours = c("blue","lightblue","yellow","orange","red"))
f2

# percent.mt
f3 <- FeaturePlot(mouse.unannotated, 
                  features = "percent.mt",
                  pt.size = 0.4, 
                  order = TRUE) + 
  scale_colour_gradientn(colours = c("blue","lightblue","yellow","orange","red"))
f3

# cell.complexity
f4 <- FeaturePlot(mouse.unannotated, 
                  features = "cell.complexity",
                  pt.size = 0.4, 
                  order = TRUE) + 
  scale_colour_gradientn(colours = c("blue","lightblue","yellow","orange","red"))
f4

# percent.ribo
f5 <- FeaturePlot(mouse.unannotated, 
                  features = "percent.ribo.protein",
                  pt.size = 0.4, 
                  order = TRUE) + 
  scale_colour_gradientn(colours = c("blue","lightblue","yellow","orange","red"))
f5

# percent.hb
f6 <- FeaturePlot(mouse.unannotated, 
                  features = "percent.hb",
                  pt.size = 0.4, 
                  order = TRUE) + 
  scale_colour_gradientn(colours = c("blue","lightblue","yellow","orange","red"))
f6
```

```{r,echo=FALSE,eval=FALSE,message=FALSE,warning=FALSE}
# save
path <- "../../results/UMAP/UMAP_unannotated_nCount"
f1
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# save
path <- "../../results/UMAP/UMAP_unannotated_nFeature"
f2
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# save
path <- "../../results/UMAP/UMAP_unannotated_percent.mt"
f3
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# save
path <- "../../results/UMAP/UMAP_unannotated_cell.complexity"
f4
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# save
path <- "../../results/UMAP/UMAP_unannotated_percent.ribo"
f5
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

# save
path <- "../../results/UMAP/UMAP_unannotated_percent.hb"
f6
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
dev.off()

remove(f1,f2,f3,f4,f5,f6)
```

## Percent cells per cluster
```{r percent_cells_per_cluster}
# sample
b1 <- mouse.unannotated@meta.data %>%
  group_by(seurat_clusters, sample) %>%
  dplyr::count() %>%
  group_by(seurat_clusters) %>%
  dplyr::mutate(percent = 100*n/sum(n)) %>%
  ungroup() %>%
  ggplot(aes(x=seurat_clusters,y=percent, fill=sample)) +
  theme_classic() +
  geom_col() +
  scale_fill_manual(values = sample_colors) +
  ggtitle("Percentage of sample per cluster")
b1

# isoform
b2 <- mouse.unannotated@meta.data %>%
  group_by(seurat_clusters, isoform) %>%
  dplyr::count() %>%
  group_by(seurat_clusters) %>%
  dplyr::mutate(percent = 100*n/sum(n)) %>%
  ungroup() %>%
  ggplot(aes(x=seurat_clusters,y=percent, fill=isoform)) +
  theme_classic() +
  geom_col() +
  scale_fill_manual(values = isoform_colors) +
  ggtitle("Percentage of isoform per cluster")
b2

# age
b3 <- mouse.unannotated@meta.data %>%
  group_by(seurat_clusters, age) %>%
  dplyr::count() %>%
  group_by(seurat_clusters) %>%
  dplyr::mutate(percent = 100*n/sum(n)) %>%
  ungroup() %>%
  ggplot(aes(x=seurat_clusters,y=percent, fill=age)) +
  theme_classic() +
  geom_col() +
  scale_fill_manual(values = age_colors) +
  ggtitle("Percentage of age per cluster")
b3

# sex
b4 <- mouse.unannotated@meta.data %>%
  group_by(seurat_clusters, sex) %>%
  dplyr::count() %>%
  group_by(seurat_clusters) %>%
  dplyr::mutate(percent = 100*n/sum(n)) %>%
  ungroup() %>%
  ggplot(aes(x=seurat_clusters,y=percent, fill=sex)) +
  theme_classic() +
  geom_col() +
  scale_fill_manual(values = sex_colors) +
  ggtitle("Percentage of sex per cluster")
b4

# Phase
b5 <- mouse.unannotated@meta.data %>%
  group_by(seurat_clusters, Phase) %>%
  dplyr::count() %>%
  group_by(seurat_clusters) %>%
  dplyr::mutate(percent = 100*n/sum(n)) %>%
  ungroup() %>%
  ggplot(aes(x=seurat_clusters,y=percent, fill=Phase)) +
  theme_classic() +
  geom_col() +
  ggtitle("Percentage of phase per cluster")
b5
```

```{r,echo=FALSE,eval=FALSE}
# save
path <- "../../results/proportion/percent_sample_per_cluster_unannotated"
b1
saveToPDF(paste0(path, ".pdf"), width = 8, height = 6)
dev.off()

# save
path <- "../../results/proportion/percent_isoform_per_cluster_unannotated"
b2
saveToPDF(paste0(path, ".pdf"), width = 8, height = 6)
dev.off()

# save
path <- "../../results/proportion/percent_age_per_cluster_unannotated"
b3
saveToPDF(paste0(path, ".pdf"), width = 8, height = 6)
dev.off()

# save
path <- "../../results/proportion/percent_sex_per_cluster_unannotated"
b4
saveToPDF(paste0(path, ".pdf"), width = 8, height = 6)
dev.off()

# save
path <- "../../results/proportion/percent_phase_per_cluster_unannotated"
b5
saveToPDF(paste0(path, ".pdf"), width = 8, height = 6)
dev.off()
```

## Number cells per cluster
```{r cells_per_cluster}
# sample
sample_ncells <- FetchData(mouse.unannotated, 
                     vars = c("ident", "sample")) %>%
  dplyr::count(ident, sample) %>%
  tidyr::spread(ident, n)
sample_ncells
write.table(sample_ncells, 
            "../../results/ncells/cells_per_cluster_per_sample_uannotated.tsv",
            quote = FALSE, sep = "\t", row.names = FALSE)

# age
age_ncells <- FetchData(mouse.unannotated, 
                     vars = c("ident", "age")) %>%
  dplyr::count(ident, age) %>%
  tidyr::spread(ident, n)
age_ncells
write.table(age_ncells, 
            "../../results/ncells/cells_per_cluster_per_age_unannotated.tsv",
            quote = FALSE, sep = "\t", row.names = FALSE)

# sex
sex_ncells <- FetchData(mouse.unannotated, 
                     vars = c("ident", "sex")) %>%
  dplyr::count(ident, sex) %>%
  tidyr::spread(ident, n)
sex_ncells
write.table(sex_ncells, 
            "../../results/ncells/cells_per_cluster_per_sex_unannoated.tsv",
            quote = FALSE, sep = "\t", row.names = FALSE)

# isoform
isoform_ncells <- FetchData(mouse.unannotated, 
                     vars = c("ident", "isoform")) %>%
  dplyr::count(ident, isoform) %>%
  tidyr::spread(ident, n)
isoform_ncells
write.table(isoform_ncells, 
            "../../results/ncells/cells_per_cluster_per_isoform_unannotated.tsv",
            quote = FALSE, sep = "\t", row.names = FALSE)

# phase
phase_ncells <- FetchData(mouse.unannotated, 
                     vars = c("ident", "Phase")) %>%
  dplyr::count(ident, Phase) %>%
  tidyr::spread(ident, n)
phase_ncells
write.table(phase_ncells, 
            "../../results/ncells/cells_per_cluster_per_phase_unannotated.tsv",
            quote = FALSE, sep = "\t", row.names = FALSE)
```

