---
title: "PLX5622 Diet Mice scRNAseq"
subtitle: "DE Figures and Additional Analyses"
author: "Kennedi Todd"
date: "02/12/2025"
output:
  html_document:
    theme: cerulean
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: inline
---

# Setup
## Working directory
```{r working_directory}
knitr::opts_knit$set(root.dir = ".")
```

## Libraries
```{r libraries, message=FALSE, warning=FALSE}
library(ComplexHeatmap) # Legend()
library(ComplexUpset) # instersection_size()
library(dplyr)        # ungroup()
library(ggrepel)      # geom_text_repel()
library(gridExtra)    # grid.arrange()
library(gtools)       # smartbind()
library(nichenetr)    # get_expressed_genes()
library(parallel)     # detectCores()
library(plotly)       # plot_ly()
library(purrr)        # set_names()
library(Seurat)       # DimPlot()
library(tibble)       # column_to_rownames()
library(tidyr)        # %>%
library(UpSetR)       # fromList()
```

## Load data
```{r load_data}
mouse.annotated <- readRDS("../../rObjects/annotated_downsampled_seurat_obj.rds")
out <- "../../results/"
```

## UMAP
```{r umap}
# set colors
cluster_colors <- c("#B5B9BA", # Pericytes and SMCs
                    "#3385BB", # BECs
                    "#40BBFF", # LECs
                    "#A5D5A9", # B cells
                    "#1C7E24", # T and NK cells
                    "#F57C7C", # ILCs
                    "#E42622", # Dendritic cells
                    "#FBB268", # Neutrophils
                    "#FE8D19", # Macrophages
                    "#DE9E83", # Myeloid precursors
                    "#A6CEE3", # Mast cells
                    "#9D7BBA", # Fibroblasts
                    "#977899") # Schwann cells

# umap
Idents(mouse.annotated) <- "annotated_clusters"
DimPlot(object = mouse.annotated,
        reduction = "umap",
        repel = TRUE,
        group.by = "annotated_clusters",
        cols = cluster_colors)
```

# DEG tables and figures
## Compare DEGs
```{r compare_degs, eval=FALSE}
# get file paths
files <- list.files(paste0(out, "DEGs/DEG_tables"))
files <- files[grepl("_DEGs.tsv", files)]

# init data.frame
deg.df <- data.frame()

# loop through files
for (i in files) {
  
  # read table
  df <- read.table(paste0(out, "DEGs/DEG_tables/", i),
                   sep = "\t", 
                   header = TRUE)
  
  # filter
  df <- df[df$p_val_adj < 0.05,]
  
  # add direction column
  comparisonName <- gsub("_DEGs.tsv", "", i)
  direction <- df$avg_log2FC > 0
  direction <- gsub(TRUE, paste0(comparisonName, "_up"), direction)
  direction <- gsub(FALSE, paste0(comparisonName, "_down"), direction)
  df$direction <- direction
  
  # reformat table
  df <- df %>% 
    dplyr::count(cluster, direction) %>%
    tidyr::spread(cluster, n)
  
  # add to master table
  deg.df <- smartbind(deg.df, df)
}

# reformat
deg.df[is.na(deg.df)] <- 0
rownames(deg.df) <- deg.df$direction
deg.df$direction <- NULL
```

```{r,echo=FALSE,eval=FALSE}
# save
write.table(deg.df, 
            paste0(out, "DEGs/DEG_tables/DEG_comparison_FDRq_0.05_LFC_0.00.tsv"),
            sep = "\t", quote = FALSE, row.names = TRUE)
```

## DEG heatmap
```{r deg_heatmap}
paletteLength <- 100
myColor <- colorRampPalette(c("white","#f0eb9e","darkgreen"))(paletteLength)

# save
path <- paste0(out, "DEGs/DEG_tables/DEG_comparison_heatmap_FDRq_0.05_LFC_0.00.pdf")
pdf(path, width = 10, height = 6)

# plot
pheatmap::pheatmap(deg.df,
                   main = "FDRq < 0.05, |LFC| > 0",
                   treeheight_row = 0,
                   treeheight_col = 0,
                   color = myColor,
                   cluster_rows = FALSE,
                   display_numbers = round(deg.df, digits = 0),
                   fontsize_number = 12,
                   number_color = "black")
```

## Volcano
```{r volcano_plot, message=FALSE, eval=FALSE}
variables <- c("E3PM_vs_E3CM","E4PM_vs_E4CM",
               "E3PF_vs_E3CF","E4PF_vs_E4CF",
               "E4CM_vs_E3CM","E4CF_vs_E3CF",
               "E4PM_vs_E3PM","E4PF_vs_E3PF",
               "E4PM_vs_E3CM","E4PF_vs_E3CF")
all_clusters <- levels(mouse.annotated$annotated_clusters)

for (i in variables) {
  
  # read DEG file
  treatment_vs_control <- read.delim(paste0(out, "DEGs/DEG_tables/", i, "_DEGs.tsv"))
  
  # assign colors
  color_values <- vector()
  max <- nrow(treatment_vs_control)
  for(row in 1:max){
    if (treatment_vs_control$p_val_adj[row] < 0.05){
      if (treatment_vs_control$avg_log2FC [row] > 0){
        color_values <- c(color_values, 1) # 1 when logFC > 0 and FDRq < 0.05
      }
      else if (treatment_vs_control$avg_log2FC[row] < 0){
        color_values <- c(color_values, 2) # 2 when logFC < 0 and FDRq < 0.05
      }
    }
    else{
      color_values <- c(color_values, 3) # 3 when FDRq >= 0.05
    }
  }
  treatment_vs_control$color_adjpval_0.05 <- factor(color_values)
  
  # loop through clusters
  for (j in all_clusters) {
    
    # subset cluster
    data <- subset(treatment_vs_control, cluster == j)
    
    # plot only if there are DEGs with p_val_adj < 0.05
    num <- subset(data, p_val_adj < 0.05)
    num <- nrow(num)
    if(num != 0) {
        
      # subset genes to label
      up <- data[data$color_adjpval_0.05 == 1,]
      up.sig <- up[order(up$p_val_adj),][1:15,]
      up.lfc <- up[order(up$avg_log2FC, decreasing = TRUE),][1:15,]
      up30 <- rbind(up.sig,up.lfc)
      up30 <- unique(up30)
      up30 <- up30[rowSums(is.na(up30)) != ncol(up30), ]
      down <- data[data$color_adjpval_0.05 == 2,]
      down.sig <- down[order(down$p_val_adj),][1:15,]
      down.lfc <- down[order(down$avg_log2FC, decreasing = FALSE),][1:15,]
      down30 <- rbind(down.sig,down.lfc)
      down30 <- unique(down30)
      down30 <- down30[rowSums(is.na(down30)) != ncol(down30), ]
      
      # set manual colors
      if (!1 %in% unique(data$color_adjpval_0.05)) {
        my_colors <- c("blue","gray")
      } else if (!2 %in% unique(data$color_adjpval_0.05)) {
        my_colors <- c("red","gray")
      } else if (!1 %in% unique(data$color_adjpval_0.05) && !2 %in% unique(data$color_adjpval_0.05)) {
        my_colors <- c("gray")
      } else {
        my_colors <- c("red","blue","gray")
      }
      
      # set significance threshold
      hadjpval <- (-log10(max(
        data$p_val[data$p_val_adj < 0.05], 
        na.rm=TRUE)))

      # plot
      p <-
        ggplot(data = data, 
               aes(x = avg_log2FC,  # x-axis is logFC
                   y = -log10(p_val),  # y-axis will be -log10 of P.Value
                   color = color_adjpval_0.05)) +  # color is based on factored color column
        geom_point(alpha = 0.8, size = 2) +  # create scatterplot, alpha makes points transparent
        theme_bw() +  # set color theme
        theme(legend.position = "none") +  # no legend
        scale_color_manual(values = my_colors) +  # set factor colors
        labs(
          title = "", # no main title
          x = expression(log[2](FC)), # x-axis title
          y = expression(-log[10] ~ "(" ~ italic("p") ~ "-value)") # y-axis title
        ) +
        theme(axis.title.x = element_text(size = 10),
              axis.text.x = element_text(size = 10)) +
        theme(axis.title.y = element_text(size = 10),
              axis.text.y = element_text(size = 10)) +
        geom_hline(yintercept = hadjpval,  #  horizontal line
                           colour = "#000000",
                           linetype = "dashed") +
        ggtitle(paste0(j,"\n",i,", p_val_adj < 0.05")) +
        geom_text_repel(data = up30,
                        aes(x = avg_log2FC, y= -log10(p_val), label = gene), 
                        color = "maroon", 
                        fontface="italic",
                        max.overlaps = getOption("ggrepel.max.overlaps", default = 30)
                        ) +
        geom_text_repel(data = down30,
                        aes(x = avg_log2FC, y= -log10(p_val), label = gene), 
                        color = "navyblue", 
                        fontface="italic",
                        max.overlaps = getOption("ggrepel.max.overlaps", default = 30)
                        )
      p
      
      # save
      clus <- j
      clus <- gsub(" ", "_", clus)
      path <- paste0(out, "DEGs/volcano/", i, "/", i, "_", clus, "_volcano.pdf")
      pdf(path, height = 8, width = 8)
      print(p)
      dev.off()
      
      print(paste("i =",i,", j =",j))
      
    }
  } # end loop through clusters
} # end loop through variables
```

## Metascape input
```{r metascape_input}
# set variables
thresh <- 0.05

# get file list
files <- list.files(paste0(out, "DEGs/DEG_tables/"))
keep <- grep("_DEGs.tsv", files)
files <- files[keep]
files <- paste0(out, "DEGs/DEG_tables/", files)

# get cell types
cell_types <- levels(mouse.annotated$annotated_clusters)

# loop through files
for (i in 1:length(files)) {
  
  # read table
  data <- read.table(files[i], header = TRUE, sep = "\t")
  data <- data[data$p_val_adj < thresh,]
  up.df <- data[data$avg_log2FC > 0,]
  down.df <- data[data$avg_log2FC < 0,]
  
  # loop through cluster
  for (j in cell_types) {
    
    # subset based on cluster
    print(paste0(i, ": ", j))
    up <- up.df[up.df$cluster == j,]
    up <- up$gene
    down <- down.df[down.df$cluster == j,]
    down <- down$gene
    
    # file name
    clus <- j
    clus <- gsub(" ", "_", clus)
    file <- gsub(paste0(out, "DEGs/DEG_tables/"), "", files[i])
    file <- gsub("_DEGs.tsv", "", file)
    file <- paste0(out, "DEGs/metascape_input/", file, "/", clus)
     
    # save
    if(length(up) > 10) {
      write.table(x = up,
                  file = paste0(file, "_up_FDRq_", format(thresh, nsmall = 2), ".tsv"),
                  quote = FALSE,
                  row.names = FALSE,
                  col.names = FALSE)      
    }
    if (length(down) > 10) {
       write.table(x = down,
                file = paste0(file, "_down_FDRq_", format(thresh, nsmall = 2), ".tsv"),
                quote = FALSE,
                row.names = FALSE,
                col.names = FALSE)   
    }
  } # end j for loop
} # end i for loop
```

## Upset plots
### Function
```{r upset_function}
get_exclusive_intersection_genes <- function(upset_data, list_input) {
  # Initialize a list to store the results
  results <- list()
  
  # Get the names of the columns (gene sets)
  set_names <- colnames(upset_data)
  
  # For each row of the UpSet matrix, extract the exclusive intersection
  for (i in 1:nrow(upset_data)) {
    # Check which sets (columns) are "active" (i.e., 1) for the current row
    active_sets <- set_names[upset_data[i, ] == 1]
    
    if (length(active_sets) > 0) {
      # Find the intersection of genes in the active sets
      intersected_genes <- Reduce(intersect, list_input[active_sets])
      
      # Find genes that are present in any of the other sets (not part of this combination)
      other_sets <- set_names[upset_data[i, ] == 0]
      other_genes <- Reduce(union, list_input[other_sets])
      
      # Subtract the genes that are in the other sets to make the intersection exclusive
      exclusive_genes <- setdiff(intersected_genes, other_genes)
      
      # Create a label for the current intersection (e.g., "Set1 & Set2")
      intersection_label <- paste(active_sets, collapse = " & ")
      
      # Store the number of genes and the exclusive gene list
      results[[intersection_label]] <- list(
        total_genes = length(exclusive_genes),
        gene_list = paste(exclusive_genes, collapse = ", ")
      )
    }
  }
  
  return(results)
}
```

### P vs C Up-regulated
```{r E4_vs_E3_upreg_tables}
# read tables
prefix <- paste0(out, "DEGs/DEG_tables/")
E3PM_vs_E3CM <- read.table(paste0(prefix,"E3PM_vs_E3CM_DEGs.tsv"),
                         sep = "\t", 
                         header = TRUE)
E4PM_vs_E4CM <- read.table(paste0(prefix,"E4PM_vs_E4CM_DEGs.tsv"),
                         sep = "\t", 
                         header = TRUE)
E3PF_vs_E3CF <- read.table(paste0(prefix,"E3PF_vs_E3CF_DEGs.tsv"),
                           sep = "\t", 
                           header = TRUE)

E4PF_vs_E4CF <- read.table(paste0(prefix,"E4PF_vs_E4CF_DEGs.tsv"),
                           sep = "\t", 
                           header = TRUE)

# filter
E3PM_vs_E3CM <- E3PM_vs_E3CM[E3PM_vs_E3CM$p_val_adj < 0.05,]
E4PM_vs_E4CM <- E4PM_vs_E4CM[E4PM_vs_E4CM$p_val_adj < 0.05,]
E3PF_vs_E3CF <- E3PF_vs_E3CF[E3PF_vs_E3CF$p_val_adj < 0.05,]
E4PF_vs_E4CF <- E4PF_vs_E4CF[E4PF_vs_E4CF$p_val_adj < 0.05,]
```

```{r E4_vs_E3_upreg_upset, eval=FALSE}
# loop through cell types
clusters <- unique(c(E3PM_vs_E3CM$cluster, E4PM_vs_E4CM$cluster,
                     E3PF_vs_E3CF$cluster, E4PF_vs_E4CF$cluster))

for (i in clusters) {
  
  # Skip cluster with not enough DEGs
  if (i == "LECs") {
    next
  }
  
  # Subset df by cluster
  E3PM_vs_E3CM_ct <- E3PM_vs_E3CM[E3PM_vs_E3CM$cluster == i,]
  E4PM_vs_E4CM_ct <- E4PM_vs_E4CM[E4PM_vs_E4CM$cluster == i,]
  E3PF_vs_E3CF_ct <- E3PF_vs_E3CF[E3PF_vs_E3CF$cluster == i,]
  E4PF_vs_E4CF_ct <- E4PF_vs_E4CF[E4PF_vs_E4CF$cluster == i,]
  
  # Subset by log2FC
  E3PM_vs_E3CM_ct_up <- E3PM_vs_E3CM_ct[E3PM_vs_E3CM_ct$avg_log2FC > 0,][,"gene"]
  E4PM_vs_E4CM_ct_up <- E4PM_vs_E4CM_ct[E4PM_vs_E4CM_ct$avg_log2FC > 0,][,"gene"]
  E3PF_vs_E3CF_ct_up <- E3PF_vs_E3CF_ct[E3PF_vs_E3CF_ct$avg_log2FC > 0,][,"gene"]
  E4PF_vs_E4CF_ct_up <- E4PF_vs_E4CF_ct[E4PF_vs_E4CF_ct$avg_log2FC > 0,][,"gene"]
  axis_max <- max(length(E3PM_vs_E3CM_ct_up), length(E4PM_vs_E4CM_ct_up),
                  length(E3PF_vs_E3CF_ct_up), length(E4PF_vs_E4CF_ct_up)) + 300
  axis_max <- ceiling(axis_max / 100) * 100
 
  # format in a list
  list_input <- list(
    "E3PM vs E3CM Up-regulated" = E3PM_vs_E3CM_ct_up,
    "E4PM vs E4CM Up-regulated" = E4PM_vs_E4CM_ct_up,
    "E3PF vs E3CF Up-regulated" = E3PF_vs_E3CF_ct_up,
    "E4PF vs E4CF Up-regulated" = E4PF_vs_E4CF_ct_up
  )
  data <- UpSetR::fromList(list_input)
  
  # You will specify the male and female groups by their group number
  # Print this to help assign shapes/colors below
  group_mapping <- data.frame(
    Group_Number = 1:4,  # Group numbers (1-8)
    Gene_Set_Name = sort(colnames(data))  # Sorted gene set names
  )
  
  # Assign shapes based on group numbers
  male_groups <- c("2","4")  # Male group numbers
  female_groups <- c("1","3")  # Female group numbers
  
  # Assign colors and shapes based on specific group numbers
  upregulated_groups <- c("1","2","3","4")
  downregulated_groups <- c()
  
  # Create the basic UpSet plot (no dynamic colors or shapes) to extract n_points
  dummy_upset <- ComplexUpset::upset(
    data, 
    colnames(data),  # Use column names (gene sets)
    set_sizes = ComplexUpset::upset_set_size(),  # Display set sizes
    sort_sets = FALSE,
    
    # Plot the intersection matrix with points (default shapes)
    matrix = ComplexUpset::intersection_matrix(
      ggplot2::geom_point(size = 3)  # Simple points without dynamic aesthetics
    )
  )
  
  # Ensure n_points matches the actual data
  n_points <- nrow(dummy_upset$data)
  
  # Create empty vectors for colors and shapes
  color_vector <- rep(NA, n_points)  # To store colors
  shape_vector <- rep(NA, n_points)  # To store shapes
  
  # Assign shapes and colors based on group numbers
  for (j in 1:n_points) {
    group_value <- as.character(dummy_upset$data$group[j])
    
    # Assign shapes
    if (group_value %in% male_groups) {
      shape_vector[j] <- 22  # Filled square for Male comparisons
    } else if (group_value %in% female_groups) {
      shape_vector[j] <- 21  # Circle for Female comparisons
    }
    
    # Assign colors based on group numbers, only if the point is involved in an intersection
    if (dummy_upset$data$value[j]) {  # If the point is part of an intersection
      if (group_value %in% upregulated_groups) {
        color_vector[j] <- "red"  # Red for Up-regulated
      } else if (group_value %in% downregulated_groups) {
        color_vector[j] <- "blue"  # Blue for Down-regulated
      }
    } else {
      color_vector[j] <- NA  # No fill for points not involved in intersections
    }
  }
  
  # Ensure both vectors are of correct length
  if (length(shape_vector) != n_points || length(color_vector) != n_points) {
    stop("Error: shape_vector or color_vector length does not match the number of plotted points.")
  }
  
  # Reintroduce dynamic fill color for filled shapes
  upset_gene <- ComplexUpset::upset(
    data, 
    colnames(data),
    set_sizes = (
      ComplexUpset::upset_set_size() +
      geom_text(aes(label = ..count..), hjust = 1.1, stat = 'count') +
      expand_limits(y = axis_max)
    ),
    
    # Prevent automatic sorting of sets
    sort_sets = FALSE,
    
    matrix = ComplexUpset::intersection_matrix(
      ggplot2::geom_point(
        ggplot2::aes(shape = factor(shape_vector), fill = color_vector),  # Fill shapes with dynamic colors
        size = 3,
        stroke = 0.45  # Keeps the outline black
      )
    ) + ggplot2::scale_shape_manual(
      name = "Sex",
      labels = c("Male", "Female"),  # Legend labels
      values = c(21, 22) # Circle=21, Filled square=22
      ) + ggplot2::scale_fill_identity(na.translate = FALSE),  # Use the exact colors in color_vector and remove NA fill
    
      base_annotations = list(
      'Intersection size' = (
        intersection_size(bar_number_threshold = 1, width = 0.5) +
        scale_y_continuous(expand = expansion(mult = c(0, 0.05)), limits = c(0, axis_max)) +
        theme(
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(colour = 'black')
        )
      )
    ),
  )
  
  # give title
  upset_gene <- upset_gene + ggtitle(paste0(i,", adj_p_val < 0.05"))
  
  # remove legend
  upset_gene <- upset_gene + theme(legend.position = "None")
  
  # save
  i <- gsub(" ","_",i)
  pdf(paste0(out, "DEGs/upset/P_vs_C_upreg/",tolower(i),"_upset.pdf"), height = 6, width = 12)
  print(upset_gene)
  dev.off()
}
```


### P vs C Down-regulated
```{r E4_vs_E3_downreg_tables}
# read tables
prefix <- paste0(out, "DEGs/DEG_tables/")
E3PM_vs_E3CM <- read.table(paste0(prefix,"E3PM_vs_E3CM_DEGs.tsv"),
                         sep = "\t", 
                         header = TRUE)
E4PM_vs_E4CM <- read.table(paste0(prefix,"E4PM_vs_E4CM_DEGs.tsv"),
                         sep = "\t", 
                         header = TRUE)
E3PF_vs_E3CF <- read.table(paste0(prefix,"E3PF_vs_E3CF_DEGs.tsv"),
                           sep = "\t", 
                           header = TRUE)

E4PF_vs_E4CF <- read.table(paste0(prefix,"E4PF_vs_E4CF_DEGs.tsv"),
                           sep = "\t", 
                           header = TRUE)

# filter
E3PM_vs_E3CM <- E3PM_vs_E3CM[E3PM_vs_E3CM$p_val_adj < 0.05,]
E4PM_vs_E4CM <- E4PM_vs_E4CM[E4PM_vs_E4CM$p_val_adj < 0.05,]
E3PF_vs_E3CF <- E3PF_vs_E3CF[E3PF_vs_E3CF$p_val_adj < 0.05,]
E4PF_vs_E4CF <- E4PF_vs_E4CF[E4PF_vs_E4CF$p_val_adj < 0.05,]
```

```{r E4_vs_E3_downreg_upset, eval=FALSE}
# loop through cell types
clusters <- unique(c(E3PM_vs_E3CM$cluster, E4PM_vs_E4CM$cluster,
                     E3PF_vs_E3CF$cluster, E4PF_vs_E4CF$cluster))

for (i in clusters) {
  
  # Subset df by cluster
  E3PM_vs_E3CM_ct <- E3PM_vs_E3CM[E3PM_vs_E3CM$cluster == i,]
  E4PM_vs_E4CM_ct <- E4PM_vs_E4CM[E4PM_vs_E4CM$cluster == i,]
  E3PF_vs_E3CF_ct <- E3PF_vs_E3CF[E3PF_vs_E3CF$cluster == i,]
  E4PF_vs_E4CF_ct <- E4PF_vs_E4CF[E4PF_vs_E4CF$cluster == i,]
  
  # Subset by log2FC
  E3PM_vs_E3CM_ct_down <- E3PM_vs_E3CM_ct[E3PM_vs_E3CM_ct$avg_log2FC < 0,][,"gene"]
  E4PM_vs_E4CM_ct_down <- E4PM_vs_E4CM_ct[E4PM_vs_E4CM_ct$avg_log2FC < 0,][,"gene"]
  E3PF_vs_E3CF_ct_down <- E3PF_vs_E3CF_ct[E3PF_vs_E3CF_ct$avg_log2FC < 0,][,"gene"]
  E4PF_vs_E4CF_ct_down <- E4PF_vs_E4CF_ct[E4PF_vs_E4CF_ct$avg_log2FC < 0,][,"gene"]
  axis_max <- max(length(E3PM_vs_E3CM_ct_down), length(E4PM_vs_E4CM_ct_down),
                  length(E3PF_vs_E3CF_ct_down), length(E4PF_vs_E4CF_ct_down)) + 200
  axis_max <- ceiling(axis_max / 100) * 100
 
  # format in a list
  list_input <- list(
    "E3PM vs E3CM down-regulated" = E3PM_vs_E3CM_ct_down,
    "E4PM vs E4CM down-regulated" = E4PM_vs_E4CM_ct_down,
    "E3PF vs E3CF down-regulated" = E3PF_vs_E3CF_ct_down,
    "E4PF vs E4CF down-regulated" = E4PF_vs_E4CF_ct_down
  )
  data <- UpSetR::fromList(list_input)
  
  # You will specify the male and female group by their group number
  # Print this to help assign shapes/colors below
  group_mapping <- data.frame(
    Group_Number = 1:4,  # Group numbers (1-4)
    Gene_Set_Name = sort(colnames(data))  # Sorted gene set names
  )
  
  # Assign shapes based on group numbers
  male_groups <- c("2","4")  # Male group numbers
  female_groups <- c("1","3")  # Female group numbers
  
  # Assign colors and shapes based on specific group numbers
  upregulated_groups <- c()
  downregulated_groups <- c("1","2","3","4")
  
  # Create the basic upset plot (no dynamic colors or shapes) to extract n_points
  dummy_upset <- ComplexUpset::upset(
    data, 
    colnames(data),  # Use column names (gene sets)
    set_sizes = ComplexUpset::upset_set_size(),  # Display set sizes
    sort_sets = FALSE,
    
    # Plot the intersection matrix with points (default shapes)
    matrix = ComplexUpset::intersection_matrix(
      ggplot2::geom_point(size = 3)  # Simple points without dynamic aesthetics
    )
  )
  
  # Ensure n_points matches the actual data
  n_points <- nrow(dummy_upset$data)
  
  # Create empty vectors for colors and shapes
  color_vector <- rep(NA, n_points)  # To store colors
  shape_vector <- rep(NA, n_points)  # To store shapes
  
  # Assign shapes and colors based on group numbers
  for (j in 1:n_points) {
    group_value <- as.character(dummy_upset$data$group[j])
    
    # Assign shapes
    if (group_value %in% male_groups) {
      shape_vector[j] <- 22  # Filled square for Male comparisons
    } else if (group_value %in% female_groups) {
      shape_vector[j] <- 21  # Circle for Female comparisons
    }
    
    # Assign colors based on group numbers, only if the point is involved in an intersection
    if (dummy_upset$data$value[j]) {  # If the point is part of an intersection
      if (group_value %in% upregulated_groups) {
        color_vector[j] <- "red"  # Red for Up-regulated
      } else if (group_value %in% downregulated_groups) {
        color_vector[j] <- "blue"  # Blue for Down-regulated
      }
    } else {
      color_vector[j] <- NA  # No fill for points not involved in intersections
    }
  }
  
  # Ensure both vectors are of correct length
  if (length(shape_vector) != n_points || length(color_vector) != n_points) {
    stop("Error: shape_vector or color_vector length does not match the number of plotted points.")
  }
  
  # Reintroduce dynamic fill color for filled shapes
  upset_gene <- ComplexUpset::upset(
    data, 
    colnames(data),
    set_sizes = (
      ComplexUpset::upset_set_size() +
      geom_text(aes(label = ..count..), hjust = 1.1, stat = 'count') +
      expand_limits(y = axis_max)
    ),
    
    # Prevent automatic sorting of sets
    sort_sets = FALSE,
    
    matrix = ComplexUpset::intersection_matrix(
      ggplot2::geom_point(
        ggplot2::aes(shape = factor(shape_vector), fill = color_vector),  # Fill shapes with dynamic colors
        size = 3,
        stroke = 0.45  # Keeps the outline black
      )
    ) + ggplot2::scale_shape_manual(
      name = "Sex",
      labels = c("Male", "Female"),  # Legend labels
      values = c(21, 22) # Circle=21, Filled square=22
      ) + ggplot2::scale_fill_identity(na.translate = FALSE),  # Use the exact colors in color_vector and remove NA fill
    
      base_annotations = list(
      'Intersection size' = (
        intersection_size(bar_number_threshold = 1, width = 0.5) +
        scale_y_continuous(expand = expansion(mult = c(0, 0.05)), limits = c(0, axis_max)) +
        theme(
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(colour = 'black')
        )
      )
    ),
  )
  
  # give title
  upset_gene <- upset_gene + ggtitle(paste0(i,", adj_p_val < 0.05"))
  
  # remove legend
  upset_gene <- upset_gene + theme(legend.position = "None")
  
  # save
  i <- gsub(" ","_",i)
  pdf(paste0(out, "DEGs/upset/P_vs_C_downreg/",tolower(i),"_upset.pdf"), height = 6, width = 12)
  print(upset_gene)
  dev.off()
}
```


### E4C vs E3C
```{r E4C_vs_E3C_tables}
# set thresh
thresh <- 0.05

# read tables
prefix <- paste0(out, "DEGs/DEG_tables/")
E4CF_vs_E3CF <- read.table(paste0(prefix,"E4CF_vs_E3CF_DEGs.tsv"),
                           sep = "\t",
                           header = TRUE)
E4CM_vs_E3CM <- read.table(paste0(prefix,"E4CM_vs_E3CM_DEGs.tsv"),
                           sep = "\t",
                           header = TRUE)

# filter
E4CF_vs_E3CF <- E4CF_vs_E3CF[E4CF_vs_E3CF$p_val_adj < thresh,]
E4CM_vs_E3CM <- E4CM_vs_E3CM[E4CM_vs_E3CM$p_val_adj < thresh,]
```

```{r E4C_vs_E3C_upset, eval=FALSE}
# loop through cell types
clusters <- unique(c(E4CF_vs_E3CF$cluster, E4CM_vs_E3CM$cluster))

for (i in clusters) {
  
  # skip cluster with not enough DEGs
  #if (i == "LECs") {
  #  next
  #}
  # Subset df by cluster
  E4CF_vs_E3CF_ct <- E4CF_vs_E3CF[E4CF_vs_E3CF$cluster == i,]
  E4CM_vs_E3CM_ct <- E4CM_vs_E3CM[E4CM_vs_E3CM$cluster == i,]
  
  # Subset by log2FC
  E4CF_vs_E3CF_ct_up <- E4CF_vs_E3CF_ct[E4CF_vs_E3CF_ct$avg_log2FC > 0,][,"gene"]
  E4CM_vs_E3CM_ct_up <- E4CM_vs_E3CM_ct[E4CM_vs_E3CM_ct$avg_log2FC > 0,][,"gene"]
  E4CF_vs_E3CF_ct_down <- E4CF_vs_E3CF_ct[E4CF_vs_E3CF_ct$avg_log2FC < 0,][,"gene"]
  E4CM_vs_E3CM_ct_down <- E4CM_vs_E3CM_ct[E4CM_vs_E3CM_ct$avg_log2FC < 0,][,"gene"]
  axis_max <- max(length(E4CF_vs_E3CF_ct_up), length(E4CM_vs_E3CM_ct_up),
                  length(E4CF_vs_E3CF_ct_down), length(E4CM_vs_E3CM_ct_down)) + 300
  axis_max <- ceiling(axis_max / 100) * 100
 
  # format in a list
  list_input <- list(
    "E4CM vs E3CM Down-regulated" = E4CM_vs_E3CM_ct_down,
    "E4CF vs E3CF Down-regulated" = E4CF_vs_E3CF_ct_down,
    "E4CM vs E3CM Up-regulated" = E4CM_vs_E3CM_ct_up,
    "E4CF vs E3CF Up-regulated" = E4CF_vs_E3CF_ct_up
  )
  data <- UpSetR::fromList(list_input)
  
  # You will specify the male and female groups by their group number
  # Print this to help assign shapes/colors below
  group_mapping <- data.frame(
    Group_Number = 1:4,  # Group numbers (1-8)
    Gene_Set_Name = sort(colnames(data))  # Sorted gene set names
  )
  
  # Assign shapes based on group numbers
  male_groups <- c("3","4")  # Male group numbers
  female_groups <- c("1","2")  # Female group numbers
  
  # Assign colors and shapes based on specific group numbers
  upregulated_groups <- c("2","4")
  downregulated_groups <- c("1","3")
  
  # Create the basic UpSet plot (no dynamic colors or shapes) to extract n_points
  dummy_upset <- ComplexUpset::upset(
    data, 
    colnames(data),  # Use column names (gene sets)
    set_sizes = ComplexUpset::upset_set_size(),  # Display set sizes
    sort_sets = FALSE,
    
    # Plot the intersection matrix with points (default shapes)
    matrix = ComplexUpset::intersection_matrix(
      ggplot2::geom_point(size = 3)  # Simple points without dynamic aesthetics
    )
  )
  
  # Ensure n_points matches the actual data
  n_points <- nrow(dummy_upset$data)
  
  # Create empty vectors for colors and shapes
  color_vector <- rep(NA, n_points)  # To store colors
  shape_vector <- rep(NA, n_points)  # To store shapes
  
  # Assign shapes and colors based on group numbers
  for (j in 1:n_points) {
    group_value <- as.character(dummy_upset$data$group[j])
    
    # Assign shapes
    if (group_value %in% male_groups) {
      shape_vector[j] <- 22  # Filled square for Male comparisons
    } else if (group_value %in% female_groups) {
      shape_vector[j] <- 21  # Circle for Female comparisons
    }
    
    # Assign colors based on group numbers, only if the point is involved in an intersection
    if (dummy_upset$data$value[j]) {  # If the point is part of an intersection
      if (group_value %in% upregulated_groups) {
        color_vector[j] <- "red"  # Red for Up-regulated
      } else if (group_value %in% downregulated_groups) {
        color_vector[j] <- "blue"  # Blue for Down-regulated
      }
    } else {
      color_vector[j] <- NA  # No fill for points not involved in intersections
    }
  }
  
  # Ensure both vectors are of correct length
  if (length(shape_vector) != n_points || length(color_vector) != n_points) {
    stop("Error: shape_vector or color_vector length does not match the number of plotted points.")
  }
  
  # Reintroduce dynamic fill color for filled shapes
  upset_gene <- ComplexUpset::upset(
    data, 
    colnames(data),
    set_sizes = (
      ComplexUpset::upset_set_size() +
      geom_text(aes(label = ..count..), hjust = 1.1, stat = 'count') +
      expand_limits(y = axis_max)
    ),
    
    # Prevent automatic sorting of sets
    sort_sets = FALSE,
    
    matrix = ComplexUpset::intersection_matrix(
      ggplot2::geom_point(
        ggplot2::aes(shape = factor(shape_vector), fill = color_vector),  # Fill shapes with dynamic colors
        size = 3,
        stroke = 0.45  # Keeps the outline black
      )
    ) + ggplot2::scale_shape_manual(
      name = "Sex",
      labels = c("Male", "Female"),  # Legend labels
      values = c(21, 22) # Circle=21, Filled square=22
      ) + ggplot2::scale_fill_identity(na.translate = FALSE),  # Use the exact colors in color_vector and remove NA fill
    
      base_annotations = list(
      'Intersection size' = (
        intersection_size(bar_number_threshold = 1, width = 0.5) +
        scale_y_continuous(expand = expansion(mult = c(0, 0.05)), limits = c(0, axis_max)) +
        theme(
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(colour = 'black')
        )
      )
    ),
  )
  
  # give title
  upset_gene <- upset_gene + ggtitle(paste0(i,", adj_p_val < 0.05"))
  
  # remove legend
  upset_gene <- upset_gene + theme(legend.position = "None")
  
  # save
  i <- gsub(" ","_",i)
  pdf(paste0(out, "DEGs/upset/E4C_vs_E3C/", tolower(i), "_upset.pdf"), height = 6, width = 12)
  print(upset_gene)
  dev.off()
}
```


### E4 vs E3 Up
```{r E4_vs_E3_up_read_tables}
# set thresh
thresh <- 0.05

# read tables
prefix <- paste0(out, "DEGs/DEG_tables/")
E4CF_vs_E3CF <- read.table(paste0(prefix,"E4CF_vs_E3CF_DEGs.tsv"),
                           sep = "\t",
                           header = TRUE)
E4PF_vs_E4CF <- read.table(paste0(prefix,"E4PF_vs_E4CF_DEGs.tsv"),
                           sep = "\t",
                           header = TRUE)
E4CM_vs_E3CM <- read.table(paste0(prefix,"E4CM_vs_E3CM_DEGs.tsv"),
                           sep = "\t",
                           header = TRUE)
E4PM_vs_E4CM <- read.table(paste0(prefix,"E4PM_vs_E4CM_DEGs.tsv"),
                           sep = "\t",
                           header = TRUE)


# filter
E4CF_vs_E3CF <- E4CF_vs_E3CF[E4CF_vs_E3CF$p_val_adj < thresh,]
E4PF_vs_E4CF <- E4PF_vs_E4CF[E4PF_vs_E4CF$p_val_adj < thresh,]
E4CM_vs_E3CM <- E4CM_vs_E3CM[E4CM_vs_E3CM$p_val_adj < thresh,]
E4PM_vs_E4CM <- E4PM_vs_E4CM[E4PM_vs_E4CM$p_val_adj < thresh,]
```

```{r E4_vs_E3_down_upset, eval=FALSE}
# loop through cell types
clusters <- unique(c(E4CF_vs_E3CF$cluster, E4PF_vs_E4CF$cluster,
                     E4CM_vs_E3CM$cluster, E4PM_vs_E4CM$cluster))

for (i in clusters) {
  
  # skip cluster with not enough DEGs
  if (i == "LECs") {
    next
  }
  
  # Subset df by cluster
  E4CF_vs_E3CF_ct <- E4CF_vs_E3CF[E4CF_vs_E3CF$cluster == i,]
  E4PF_vs_E4CF_ct <- E4PF_vs_E4CF[E4PF_vs_E4CF$cluster == i,]
  E4CM_vs_E3CM_ct <- E4CM_vs_E3CM[E4CM_vs_E3CM$cluster == i,]
  E4PM_vs_E4CM_ct <- E4PM_vs_E4CM[E4PM_vs_E4CM$cluster == i,]

  # Subset by log2FC
  E4CF_vs_E3CF_ct_up <- E4CF_vs_E3CF_ct[E4CF_vs_E3CF_ct$avg_log2FC > 0,][,"gene"]
  E4PF_vs_E4CF_ct_up <- E4PF_vs_E4CF_ct[E4PF_vs_E4CF_ct$avg_log2FC > 0,][,"gene"]
  E4CM_vs_E3CM_ct_up <- E4CM_vs_E3CM_ct[E4CM_vs_E3CM_ct$avg_log2FC > 0,][,"gene"]
  E4PM_vs_E4CM_ct_up <- E4PM_vs_E4CM_ct[E4PM_vs_E4CM_ct$avg_log2FC > 0,][,"gene"]
  axis_max <- max(length(E4CF_vs_E3CF_ct_up), length(E4PF_vs_E4CF_ct_up),
                  length(E4CM_vs_E3CM_ct_up), length(E4PM_vs_E4CM_ct_up)) + 300
  axis_max <- ceiling(axis_max / 100) * 100
 
  # format in a list
  list_input <- list(
    "E4PM vs E4CM Up-regulated" = E4PM_vs_E4CM_ct_up,
    "E4CM vs E3CM Up-regulated" = E4CM_vs_E3CM_ct_up,
    "E4PF vs E4CF Up-regulated" = E4PF_vs_E4CF_ct_up,
    "E4CF vs E3CF Up-regulated" = E4CF_vs_E3CF_ct_up
  )
  data <- UpSetR::fromList(list_input)
  
  # You will specify the male and female groups by their group number
  # Print this to help assign shapes/colors below
  group_mapping <- data.frame(
    Group_Number = 1:4,  # Group numbers (1-8)
    Gene_Set_Name = sort(colnames(data))  # Sorted gene set names
  )
  
  # Assign shapes based on group numbers
  male_groups <- c("2","4")  # Male group numbers
  female_groups <- c("1","3")  # Female group numbers
  
  # Assign colors and shapes based on specific group numbers
  upregulated_groups <- c("1","2","3","4")
  downregulated_groups <- c()
  
  # Create the basic UpSet plot (no dynamic colors or shapes) to extract n_points
  dummy_upset <- ComplexUpset::upset(
    data, 
    colnames(data),  # Use column names (gene sets)
    set_sizes = ComplexUpset::upset_set_size(),  # Display set sizes
    sort_sets = FALSE,
    
    # Plot the intersection matrix with points (default shapes)
    matrix = ComplexUpset::intersection_matrix(
      ggplot2::geom_point(size = 3)  # Simple points without dynamic aesthetics
    )
  )
  
  # Ensure n_points matches the actual data
  n_points <- nrow(dummy_upset$data)
  
  # Create empty vectors for colors and shapes
  color_vector <- rep(NA, n_points)  # To store colors
  shape_vector <- rep(NA, n_points)  # To store shapes
  
  # Assign shapes and colors based on group numbers
  for (j in 1:n_points) {
    group_value <- as.character(dummy_upset$data$group[j])
    
    # Assign shapes
    if (group_value %in% male_groups) {
      shape_vector[j] <- 22  # Filled square for Male comparisons
    } else if (group_value %in% female_groups) {
      shape_vector[j] <- 21  # Circle for Female comparisons
    }
    
    # Assign colors based on group numbers, only if the point is involved in an intersection
    if (dummy_upset$data$value[j]) {  # If the point is part of an intersection
      if (group_value %in% upregulated_groups) {
        color_vector[j] <- "red"  # Red for Up-regulated
      } else if (group_value %in% downregulated_groups) {
        color_vector[j] <- "blue"  # Blue for Down-regulated
      }
    } else {
      color_vector[j] <- NA  # No fill for points not involved in intersections
    }
  }
  
  # Ensure both vectors are of correct length
  if (length(shape_vector) != n_points || length(color_vector) != n_points) {
    stop("Error: shape_vector or color_vector length does not match the number of plotted points.")
  }
  
  # Reintroduce dynamic fill color for filled shapes
  upset_gene <- ComplexUpset::upset(
    data, 
    colnames(data),
    set_sizes = (
      ComplexUpset::upset_set_size() +
      geom_text(aes(label = ..count..), hjust = 1.1, stat = 'count') +
      expand_limits(y = axis_max)
    ),
    
    # Prevent automatic sorting of sets
    sort_sets = FALSE,
    
    matrix = ComplexUpset::intersection_matrix(
      ggplot2::geom_point(
        ggplot2::aes(shape = factor(shape_vector), fill = color_vector),  # Fill shapes with dynamic colors
        size = 3,
        stroke = 0.45  # Keeps the outline black
      )
    ) + ggplot2::scale_shape_manual(
      name = "Sex",
      labels = c("Male", "Female"),  # Legend labels
      values = c(21, 22) # Circle=21, Filled square=22
      ) + ggplot2::scale_fill_identity(na.translate = FALSE),  # Use the exact colors in color_vector and remove NA fill
    
      base_annotations = list(
      'Intersection size' = (
        intersection_size(bar_number_threshold = 1, width = 0.5) +
        scale_y_continuous(expand = expansion(mult = c(0, 0.05)), limits = c(0, axis_max)) +
        theme(
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(colour = 'black')
        )
      )
    ),
  )
  
  # give title
  upset_gene <- upset_gene + ggtitle(paste0(i,", adj_p_val < 0.05"))
  
  # remove legend
  upset_gene <- upset_gene + theme(legend.position = "None")
  
  # save
  i <- gsub(" ","_",i)
  pdf(paste0(out, "DEGs/upset/E4_vs_E3_upreg/", tolower(i), "_upset.pdf"), height = 6, width = 12)
  print(upset_gene)
  dev.off()
}
```


### E4 vs E3 Down
```{r E4_vs_E3_down_read_tables}
# set thresh
thresh <- 0.05

# read tables
prefix <- paste0(out, "DEGs/DEG_tables/")
E4CF_vs_E3CF <- read.table(paste0(prefix,"E4CF_vs_E3CF_DEGs.tsv"),
                           sep = "\t",
                           header = TRUE)
E4PF_vs_E4CF <- read.table(paste0(prefix,"E4PF_vs_E4CF_DEGs.tsv"),
                           sep = "\t",
                           header = TRUE)
E4CM_vs_E3CM <- read.table(paste0(prefix,"E4CM_vs_E3CM_DEGs.tsv"),
                           sep = "\t",
                           header = TRUE)
E4PM_vs_E4CM <- read.table(paste0(prefix,"E4PM_vs_E4CM_DEGs.tsv"),
                           sep = "\t",
                           header = TRUE)


# filter
E4CF_vs_E3CF <- E4CF_vs_E3CF[E4CF_vs_E3CF$p_val_adj < thresh,]
E4PF_vs_E4CF <- E4PF_vs_E4CF[E4PF_vs_E4CF$p_val_adj < thresh,]
E4CM_vs_E3CM <- E4CM_vs_E3CM[E4CM_vs_E3CM$p_val_adj < thresh,]
E4PM_vs_E4CM <- E4PM_vs_E4CM[E4PM_vs_E4CM$p_val_adj < thresh,]
```

```{r E4_vs_E3_down_upset, eval=FALSE}
# loop through cell types
clusters <- unique(c(E4CF_vs_E3CF$cluster, E4PF_vs_E4CF$cluster,
                     E4CM_vs_E3CM$cluster, E4PM_vs_E4CM$cluster))

for (i in clusters) {
  
  # skip cluster with not enough DEGs
  if (i == "LECs") {
    next
  }
  
  # Subset df by cluster
  E4CF_vs_E3CF_ct <- E4CF_vs_E3CF[E4CF_vs_E3CF$cluster == i,]
  E4PF_vs_E4CF_ct <- E4PF_vs_E4CF[E4PF_vs_E4CF$cluster == i,]
  E4CM_vs_E3CM_ct <- E4CM_vs_E3CM[E4CM_vs_E3CM$cluster == i,]
  E4PM_vs_E4CM_ct <- E4PM_vs_E4CM[E4PM_vs_E4CM$cluster == i,]

  # Subset by log2FC
  E4CF_vs_E3CF_ct_down <- E4CF_vs_E3CF_ct[E4CF_vs_E3CF_ct$avg_log2FC < 0,][,"gene"]
  E4PF_vs_E4CF_ct_down <- E4PF_vs_E4CF_ct[E4PF_vs_E4CF_ct$avg_log2FC < 0,][,"gene"]
  E4CM_vs_E3CM_ct_down <- E4CM_vs_E3CM_ct[E4CM_vs_E3CM_ct$avg_log2FC < 0,][,"gene"]
  E4PM_vs_E4CM_ct_down <- E4PM_vs_E4CM_ct[E4PM_vs_E4CM_ct$avg_log2FC < 0,][,"gene"]
  axis_max <- max(length(E4CF_vs_E3CF_ct_down), length(E4PF_vs_E4CF_ct_down),
                  length(E4CM_vs_E3CM_ct_down), length(E4PM_vs_E4CM_ct_down)) + 300
  axis_max <- ceiling(axis_max / 100) * 100
 
  # format in a list
  list_input <- list(
    "E4PM vs E4CM Down-regulated" = E4PM_vs_E4CM_ct_down,
    "E4CM vs E3CM Down-regulated" = E4CM_vs_E3CM_ct_down,
    "E4PF vs E4CF Down-regulated" = E4PF_vs_E4CF_ct_down,
    "E4CF vs E3CF Down-regulated" = E4CF_vs_E3CF_ct_down
  )
  data <- UpSetR::fromList(list_input)
  
  # You will specify the male and female groups by their group number
  # Print this to help assign shapes/colors below
  group_mapping <- data.frame(
    Group_Number = 1:4,  # Group numbers (1-8)
    Gene_Set_Name = sort(colnames(data))  # Sorted gene set names
  )
  
  # Assign shapes based on group numbers
  male_groups <- c("2","4")  # Male group numbers
  female_groups <- c("1","3")  # Female group numbers
  
  # Assign colors and shapes based on specific group numbers
  upregulated_groups <- c()
  downregulated_groups <- c("1","2","3","4")
  
  # Create the basic UpSet plot (no dynamic colors or shapes) to extract n_points
  dummy_upset <- ComplexUpset::upset(
    data, 
    colnames(data),  # Use column names (gene sets)
    set_sizes = ComplexUpset::upset_set_size(),  # Display set sizes
    sort_sets = FALSE,
    
    # Plot the intersection matrix with points (default shapes)
    matrix = ComplexUpset::intersection_matrix(
      ggplot2::geom_point(size = 3)  # Simple points without dynamic aesthetics
    )
  )
  
  # Ensure n_points matches the actual data
  n_points <- nrow(dummy_upset$data)
  
  # Create empty vectors for colors and shapes
  color_vector <- rep(NA, n_points)  # To store colors
  shape_vector <- rep(NA, n_points)  # To store shapes
  
  # Assign shapes and colors based on group numbers
  for (j in 1:n_points) {
    group_value <- as.character(dummy_upset$data$group[j])
    
    # Assign shapes
    if (group_value %in% male_groups) {
      shape_vector[j] <- 22  # Filled square for Male comparisons
    } else if (group_value %in% female_groups) {
      shape_vector[j] <- 21  # Circle for Female comparisons
    }
    
    # Assign colors based on group numbers, only if the point is involved in an intersection
    if (dummy_upset$data$value[j]) {  # If the point is part of an intersection
      if (group_value %in% upregulated_groups) {
        color_vector[j] <- "red"  # Red for Up-regulated
      } else if (group_value %in% downregulated_groups) {
        color_vector[j] <- "blue"  # Blue for Down-regulated
      }
    } else {
      color_vector[j] <- NA  # No fill for points not involved in intersections
    }
  }
  
  # Ensure both vectors are of correct length
  if (length(shape_vector) != n_points || length(color_vector) != n_points) {
    stop("Error: shape_vector or color_vector length does not match the number of plotted points.")
  }
  
  # Reintroduce dynamic fill color for filled shapes
  upset_gene <- ComplexUpset::upset(
    data, 
    colnames(data),
    set_sizes = (
      ComplexUpset::upset_set_size() +
      geom_text(aes(label = ..count..), hjust = 1.1, stat = 'count') +
      expand_limits(y = axis_max)
    ),
    
    # Prevent automatic sorting of sets
    sort_sets = FALSE,
    
    matrix = ComplexUpset::intersection_matrix(
      ggplot2::geom_point(
        ggplot2::aes(shape = factor(shape_vector), fill = color_vector),  # Fill shapes with dynamic colors
        size = 3,
        stroke = 0.45  # Keeps the outline black
      )
    ) + ggplot2::scale_shape_manual(
      name = "Sex",
      labels = c("Male", "Female"),  # Legend labels
      values = c(21, 22) # Circle=21, Filled square=22
      ) + ggplot2::scale_fill_identity(na.translate = FALSE),  # Use the exact colors in color_vector and remove NA fill
    
      base_annotations = list(
      'Intersection size' = (
        intersection_size(bar_number_threshold = 1, width = 0.5) +
        scale_y_continuous(expand = expansion(mult = c(0, 0.05)), limits = c(0, axis_max)) +
        theme(
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(colour = 'black')
        )
      )
    ),
  )
  
  # give title
  upset_gene <- upset_gene + ggtitle(paste0(i,", adj_p_val < 0.05"))
  
  # remove legend
  upset_gene <- upset_gene + theme(legend.position = "None")
  
  # save
  i <- gsub(" ","_",i)
  pdf(paste0(out, "DEGs/upset/E4_vs_E3_downreg/", tolower(i), "_upset.pdf"), height = 6, width = 12)
  print(upset_gene)
  dev.off()
}
```

# NicheNet
## Read in network
Read in the ligand-receptor network, ligand-target prior model, and weighted integrated networks.
```{r nn_refs}
# ligand-receptor network
nn_lr_network <- 
  readRDS(url("https://zenodo.org/record/7074291/files/lr_network_mouse_21122021.rds"))

# ligand-target prior model
nn_ligand_target_matrix <- 
  readRDS(url("https://zenodo.org/record/7074291/files/ligand_target_matrix_nsga2r_final_mouse.rds"))

# weighted integrated networks
nn_weighted_networks <- 
  readRDS(url("https://zenodo.org/record/7074291/files/weighted_networks_nsga2r_final_mouse.rds"))
```

## User input
- Sender cells = cells that express ligands \
- Receiver cells = cells that express the receptors \
```{r nn_user_input}
# user defined variables
groups <- c("E4PM","E4CM")
myReceiver <- "LECs"
mySenders <- c("Macrophages","BECs","B cells","T and NK cells")
receiverOut <- "receiver_LECs"
senderOut <- "/sender_macro_becs_b_t_nk_cells"

# get color map
cm <- data.frame(cell_types = levels(mouse.annotated$annotated_clusters),
                 colors = cluster_colors)
cm <- cm[cm$cell_types %in% c(myReceiver,mySenders),]

# initialize log file
log_path <- paste0(out, "nichenet/", groups[1], "_vs_", groups[2], "/", 
                   receiverOut, senderOut, "/log.txt")
cat("NicheNet Analysis\n", file = log_path, sep = "\n", append = FALSE)

# write user input to log
msg <- c("Comparison of interest:", paste0("\t", groups[1], " vs. ", groups[2]),
         "receiver:", paste0("\t", myReceiver),
         "Senders:", paste0("\t", mySenders))
cat(msg, file = log_path, append = TRUE, sep = "\n")

# filter seurat obj based on cell types of interest
mouse.nn <- subset(mouse.annotated, annotated_clusters %in% c(mySenders, myReceiver))
mouse.nn <- subset(mouse.nn, group %in% groups[1])

# get distribution of cell types and groups
df <- mouse.nn@meta.data %>% count(annotated_clusters, group, name = "Count")
df <- knitr::kable(df, format = "simple")

# write to log
msg <- c("", "Filtering cells", "", "\t\tCELL NUMBER DISTRIBUTION", df)
cat(msg, file = log_path, append = TRUE, sep = "\n")

# reset params
mouse.nn$annotated_clusters <- as.character(mouse.nn$annotated_clusters)
mouse.nn$group <- as.character(mouse.nn$group)
Idents(mouse.nn) <- "annotated_clusters"
```

## Gene set of interest
The gene set of interest is usually DEGs but since we low/none for LECs we will use genes with a avg_log2FC > +2.
```{r nn_goi}
# define gene set of interest 
# rows = target genes in the ligand target matrix
path <- paste0(out, "DEGs/DEG_tables/", groups[1], "_vs_", groups[2], "_DEGs.tsv")
goi <- read.table(file = path, sep = "\t", header = TRUE)
goi <- goi[goi$cluster == myReceiver,]
goi <- goi[goi$avg_log2FC > 2,]
goi <- goi$gene
goi <- goi %>% .[. %in% rownames(nn_ligand_target_matrix)]

# print message
msg <- paste("There are", length(goi), "genes with a avg_log2FC > +2")
print(msg)
cat(c("", "Getting gene set of interest", paste0("\t", msg)), 
    file = log_path, append = TRUE, sep = "\n")
```

## Sender-agnostic ligands
Given receptors expressed in receiver cell population, get all associated ligands.
```{r sender_agnostic}
# print receiver cell pop
paste("receiver cell population =", myReceiver)

# determine all genes expressed in receiver cell population
all_genes_receiver <- get_expressed_genes(myReceiver, mouse.nn)
msg <- paste(length(all_genes_receiver), "genes expressed in the receiver cell population.")
print(msg)
cat(c("", "Sender-agnostic info", paste0("\t", msg)), 
    file = log_path, append = TRUE, sep = "\n")

# define expressed receptors in the receiver cell population
all_receptors_receiver <- intersect(unique(nn_lr_network$to), all_genes_receiver)
msg <- paste(length(all_receptors_receiver), "receptors expressed in receiver cell population.")
print(msg)
cat(paste0("\t", msg), file = log_path, append = TRUE, sep = "\n")

# define potential ligands given expressed receptors
potential_ligands_sender_agnostic <- nn_lr_network %>% 
  filter(to %in% all_receptors_receiver) %>% 
  pull(from) %>% 
  unique()
msg <- paste("There are", length(potential_ligands_sender_agnostic), 
            "potential ligands in the sender-agnostic approach.")
print(msg)
cat(paste0("\t", msg), file = log_path, append = TRUE, sep = "\n")

# cleanup
remove(all_receptors_receiver)
```

## Sender-focused ligands
```{r sender_focused_ligands}
# get all sender cell populations
print("My sender cell types:")
print(mySenders)

# get all the expressed genes of every sender cell type separately
list_all_genes_sender <- 
  mySenders %>% 
  unique() %>% 
  lapply(get_expressed_genes, mouse.nn)
all_ligands_sender <- 
  list_all_genes_sender %>% 
  unlist() %>% 
  unique()

# display message
msg <- paste(length(all_ligands_sender), "expressed ligands from sender cell types.")
print(msg)
cat(c("", "Sender-focused info", paste0("\t", msg)),
    file = log_path, append = TRUE, sep = "\n")

# get ligands expressed in sender cell types
potential_ligands_sender_focused <- 
  intersect(potential_ligands_sender_agnostic, all_ligands_sender)

# view how many
msg <- paste(length(potential_ligands_sender_focused),
             "sender-focused ligands intersect sender-agnostic ligands.")
print(msg)
cat(paste0("\t", msg), file = log_path, append = TRUE, sep = "\n")

# cleanup
remove(list_all_genes_sender, all_ligands_sender, potential_ligands_sender_agnostic)
```

## Ligand activity
Given a gene set of interest (usually DEGs), all expressed genes in the receiver cell population, the NicheNet ligand-target matrix, and potential ligands using the sender-agnostic approach, predict activities of ligands regulating expression in the gene set of interest. AUPR (Area Under the Precision-Recall curve) integrates precision and recall into a single value, emphasizing performance on the positive class, making it suitable for unbalanced data sets like ligand-target interactions. Precision measures the proportion of true-positives to (true-positives + false-positives). Recall measures the proportion of true-positives to (true-positives + false-negatives).
```{r ligand_activity}
# define background genes
background_genes <- all_genes_receiver %>% .[. %in% rownames(nn_ligand_target_matrix)]
background_genes <- background_genes[!background_genes %in% goi]
msg <- paste("\n", length(background_genes), "background genes. Background genes are",
             "receiver expressed genes that are in the NicheNet ligand-target",
             "matrix and NOT in the gene set of interest")
print(msg)
cat(paste0("", msg), file = log_path, append = TRUE, sep = "\n")

# get ligand activity
ligand_activities_sender_focused <- predict_ligand_activities(
  geneset = goi,
  background_expressed_genes = background_genes,
  ligand_target_matrix = nn_ligand_target_matrix,
  potential_ligands = potential_ligands_sender_focused)

# reorder table
ligand_activities_sender_focused <- 
  ligand_activities_sender_focused %>% 
  arrange(-aupr_corrected) %>% 
  mutate(rank = rank(desc(aupr_corrected)))

# save output
write.table(x = ligand_activities_sender_focused,
            file = paste0(out, "nichenet/", groups[1], "_vs_", groups[2], "/",
                          receiverOut, senderOut, "/sender_focused_ligand_activity.tsv"),
            sep = "\t",
            quote = FALSE,
            row.names = FALSE)

# save top 35 ligands
best_sender_focused_ligands <- 
  ligand_activities_sender_focused %>% 
  arrange(-aupr_corrected) %>% 
  top_n(35, aupr_corrected) %>% 
  pull(test_ligand)

# cleanup
remove(all_genes_receiver, background_genes, potential_ligands_sender_focused,
       ligand_activities_sender_focused)
```

## Ligand target links
Infer ligand downstream gene targets
```{r ligand_target_links}
ligand_target_links_df <- 
  best_sender_focused_ligands %>%
  lapply(get_weighted_ligand_target_links,
         geneset = goi,
         ligand_target_matrix = nn_ligand_target_matrix) %>%
  bind_rows() %>% drop_na()
```

## Circos plot
```{r circos_plot, warning=FALSE}
# Subset seurat obj
mouse.nn.sender <- subset(mouse.nn, annotated_clusters == mySenders)
table(mouse.nn.sender$annotated_clusters)
DefaultAssay(mouse.nn.sender) <- "RNA"
Idents(mouse.nn.sender) <- "annotated_clusters"

# Assign ligands to cell types
ligand_type_indication_df <- assign_ligands_to_celltype(
  seuratObj = mouse.nn.sender,
  ligands = best_sender_focused_ligands,
  celltype_col = "annotated_clusters"
)

# Generate circos_links using get_ligand_target_links_oi
circos_links <- get_ligand_target_links_oi(
  ligand_type_indication_df = ligand_type_indication_df,
  active_ligand_target_links_df = ligand_target_links_df %>% mutate(target_type = myReceiver)
)

# Get ligand colors
ligand_colors <- ""
if("General" %in% circos_links$ligand_type) {
  subset_cm <- cm[cm$cell_types %in% mySenders,]
  subset_cm <- rbind(subset_cm, c("General","black"))
  ligand_colors <- subset_cm$colors
  names(ligand_colors) <- subset_cm$cell_types
  # update cm too
  if (!"Common ligands" %in% cm$cell_types) {
    cm <- rbind(cm, c("Common ligands", "black"))}
} else {
  subset_cm <- cm[cm$cell_types %in% mySenders,]
  ligand_colors <- subset_cm$colors
  names(ligand_colors) <- subset_cm$cell_types
}

# Get target colors
subset_cm <- cm[cm$cell_types %in% myReceiver,]
target_colors <- subset_cm$colors
names(target_colors) <- subset_cm$cell_types

# Prepare the visualization object using prepare_circos_visualization
vis_circos_obj <- prepare_circos_visualization(
  circos_links = circos_links,
  ligand_colors = ligand_colors,
  target_colors = target_colors,
  widths = NULL,
  celltype_order = NULL
)

# Create target genes legend
target_legend <- Legend(
  labels = names(target_colors),
  background = target_colors,
  type = "rect",
  grid_height = unit(3, "mm"),
  grid_width = unit(3, "mm"),
  labels_gp = gpar(fontsize = 14),
  title = "Target genes",
  title_gp = gpar(fontsize = 14)
)

# Create ligand genes legend
ligand_legend <- Legend(
  labels = gsub("General", "Common ligands", names(ligand_colors)),
  background = ligand_colors,
  type = "rect",
  grid_height = unit(3, "mm"),
  grid_width = unit(3, "mm"),
  labels_gp = gpar(fontsize = 14),
  title = "Ligand genes",
  title_gp = gpar(fontsize = 14)
)

# Combine the two legends
combined_legend <- packLegend(target_legend, ligand_legend, direction = "vertical")

# plot circos
make_circos_plot(
  vis_circos_obj,
  transparency = TRUE, 
  args.circos.text = list(cex = 0.5)  # Increase default font size slightly
)

# generate and store the updated circos plot before saving
circos_no_legend <- recordPlot()

# Save to PDF
path <- paste0(out, "nichenet/", groups[1], "_vs_", groups[2], "/", receiverOut, 
               senderOut, "/sender_focused_ligand_target_circos_plot.pdf")
pdf(path, height = 10, width = 14)
# Draw Circos plot directly inside the PDF
make_circos_plot(vis_circos_obj, transparency = TRUE, args.circos.text = list(cex = 0.5))
# Convert the legend into a grob
legend_grob <- grid.grabExpr(draw(combined_legend))
# Move legend to the right
grid::pushViewport(grid::viewport(x = 0.8, y = 0.5, width = 0.2, height = 1, just = c("left", "center")))
grid.draw(legend_grob)
grid::popViewport()
dev.off()

# Save to SVG
path <- paste0(out, "nichenet/", groups[1], "_vs_", groups[2], "/", receiverOut, 
               senderOut, "/sender_focused_ligand_target_circos_plot.svg")
svg(path, height = 10, width = 14)
# Draw Circos plot directly inside the PDF
make_circos_plot(vis_circos_obj, transparency = TRUE, args.circos.text = list(cex = 0.5))
# Convert the legend into a grob
legend_grob <- grid.grabExpr(draw(combined_legend))
# Move legend to the right
grid::pushViewport(grid::viewport(x = 0.8, y = 0.5, width = 0.2, height = 1, just = c("left", "center")))
grid.draw(legend_grob)
grid::popViewport()
dev.off()
```


```{r}

# Save
path <- paste0(out, "nichenet/", groups[1], "_vs_", groups[2], "/", receiverOut, 
               senderOut, "/sender_focused_ligand_target_circos_plot.svg")
svg(path, height = 10, width = 14)

# Plot with legend
cowplot::plot_grid(circos_no_legend, circos_legend_grob, rel_widths = c(1, 0.1))
dev.off()
```

## Dot plot
```{r dot_plot}
# save
path <- paste0(out, "nichenet/", groups[1], "_vs_", groups[2], "/", receiverOut, 
               senderOut, "/sender_focused_dot_plot.pdf")
pdf(path, height = 8, width = 10)

# dot plot
DotPlot(mouse.nn.sender,
        features = rev(best_sender_focused_ligands), 
        assay = "RNA",
        group.by = "annotated_clusters",
        cols = "RdYlBu") + 
  labs(x = "Top Ranked Ligands", y = "Sender Cell Populations") +
  coord_flip() +
  scale_y_discrete(position = "right") +
  theme(axis.text.x = element_text(angle = 45, hjust = 0))
```
